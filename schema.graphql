# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateCycle {
  _avg: CycleAvgAggregate
  _count: CycleCountAggregate
  _max: CycleMaxAggregate
  _min: CycleMinAggregate
  _sum: CycleSumAggregate
}

type AggregateIssue {
  _avg: IssueAvgAggregate
  _count: IssueCountAggregate
  _max: IssueMaxAggregate
  _min: IssueMinAggregate
  _sum: IssueSumAggregate
}

type AggregateIssueLabel {
  _count: IssueLabelCountAggregate
  _max: IssueLabelMaxAggregate
  _min: IssueLabelMinAggregate
}

type AggregateIssuePriority {
  _avg: IssuePriorityAvgAggregate
  _count: IssuePriorityCountAggregate
  _max: IssuePriorityMaxAggregate
  _min: IssuePriorityMinAggregate
  _sum: IssuePrioritySumAggregate
}

type AggregateIssueStatus {
  _count: IssueStatusCountAggregate
  _max: IssueStatusMaxAggregate
  _min: IssueStatusMinAggregate
}

type AggregateLabel {
  _count: LabelCountAggregate
  _max: LabelMaxAggregate
  _min: LabelMinAggregate
}

type AggregateProject {
  _avg: ProjectAvgAggregate
  _count: ProjectCountAggregate
  _max: ProjectMaxAggregate
  _min: ProjectMinAggregate
  _sum: ProjectSumAggregate
}

type AggregateSubtask {
  _avg: SubtaskAvgAggregate
  _count: SubtaskCountAggregate
  _max: SubtaskMaxAggregate
  _min: SubtaskMinAggregate
  _sum: SubtaskSumAggregate
}

type AggregateSyncConflict {
  _count: SyncConflictCountAggregate
  _max: SyncConflictMaxAggregate
  _min: SyncConflictMinAggregate
}

type AggregateSyncOperation {
  _avg: SyncOperationAvgAggregate
  _count: SyncOperationCountAggregate
  _max: SyncOperationMaxAggregate
  _min: SyncOperationMinAggregate
  _sum: SyncOperationSumAggregate
}

type AggregateTask {
  _avg: TaskAvgAggregate
  _count: TaskCountAggregate
  _max: TaskMaxAggregate
  _min: TaskMinAggregate
  _sum: TaskSumAggregate
}

type AggregateTaskDependency {
  _avg: TaskDependencyAvgAggregate
  _count: TaskDependencyCountAggregate
  _max: TaskDependencyMaxAggregate
  _min: TaskDependencyMinAggregate
  _sum: TaskDependencySumAggregate
}

type AggregateTaskMasterMetadata {
  _avg: TaskMasterMetadataAvgAggregate
  _count: TaskMasterMetadataCountAggregate
  _max: TaskMasterMetadataMaxAggregate
  _min: TaskMasterMetadataMinAggregate
  _sum: TaskMasterMetadataSumAggregate
}

type AggregateTeam {
  _count: TeamCountAggregate
  _max: TeamMaxAggregate
  _min: TeamMinAggregate
}

type AggregateTeamMember {
  _count: TeamMemberCountAggregate
  _max: TeamMemberMaxAggregate
  _min: TeamMemberMinAggregate
}

type AggregateTeamProject {
  _count: TeamProjectCountAggregate
  _max: TeamProjectMaxAggregate
  _min: TeamProjectMinAggregate
}

type AggregateUser {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

type CLICommand {
  args: [String!]!
  category: String!
  description: String!
  examples: [String!]
  name: String!
  parseOutput: Boolean!
  requiredArgs: [String!]!
  timeout: Float!
}

type CLIExecutionStats {
  averageExecutionTime: Float!
  commandFrequency: String!
  failedExecutions: Float!
  successRate: Float!
  successfulExecutions: Float!
  totalExecutions: Float!
}

input CLIHistoryFilter {
  command: String
  endDate: DateTime
  startDate: DateTime
  success: Boolean
}

type CLIHistoryItem {
  args: String!
  command: String!
  error: String
  executionTime: Float!
  id: ID!
  output: String!
  success: Boolean!
  timestamp: DateTime!
}

type CLIProcess {
  id: ID!
  startTime: String!
  status: String!
}

type CLIStatus {
  activeProcessCount: Float!
  activeProcesses: [CLIProcess!]!
  error: String
  executionStats: CLIExecutionStats!
  isHealthy: Boolean!
  recentCommands: [CLIHistoryItem!]!
  systemInfo: CLISystemInfo!
  timestamp: DateTime!
}

type CLISystemInfo {
  architecture: String!
  cwd: String!
  memoryUsage: String!
  nodeVersion: String!
  pid: Float!
  platform: String!
  uptime: Float!
}

type CreateManyAndReturnCycle {
  createdAt: DateTime!
  endDate: DateTime!
  id: String!
  name: String!
  number: Int!
  progress: Int!
  startDate: DateTime!
  team: Team!
  teamId: String!
  updatedAt: DateTime!
}

type CreateManyAndReturnIssue {
  assignee(where: UserWhereInput): User
  assigneeId: String
  createdAt: DateTime!
  cycle(where: CycleWhereInput): Cycle
  cycleId: String
  description: String!
  dueDate: DateTime
  id: String!
  identifier: String!
  issuePriority(where: IssuePriorityWhereInput): IssuePriority
  issueStatus(where: IssueStatusWhereInput): IssueStatus
  issueType: String!
  parentIssue(where: IssueWhereInput): Issue
  parentIssueId: String
  priority: String
  priorityId: String
  project(where: ProjectWhereInput): Project
  projectId: String
  rank: String!
  status: String
  statusId: String
  subtask(where: SubtaskWhereInput): Subtask
  subtaskId: String
  task(where: TaskWhereInput): Task
  taskId: Int
  title: String!
  updatedAt: DateTime!
}

type CreateManyAndReturnIssueLabel {
  id: String!
  issue: Issue!
  issueId: String!
  label: Label!
  labelId: String!
}

type CreateManyAndReturnIssuePriority {
  createdAt: DateTime!
  iconName: String!
  id: String!
  name: String!
  order: Int!
  updatedAt: DateTime!
}

type CreateManyAndReturnIssueStatus {
  color: String!
  createdAt: DateTime!
  iconName: String!
  id: String!
  name: String!
  updatedAt: DateTime!
}

type CreateManyAndReturnLabel {
  color: String!
  createdAt: DateTime!
  description: String
  id: String!
  name: String!
  updatedAt: DateTime!
}

type CreateManyAndReturnProject {
  color: String
  createdAt: DateTime!
  description: String
  health: String!
  icon: String
  id: String!
  identifier: String
  lead(where: UserWhereInput): User
  leadId: String
  name: String!
  percentComplete: Int!
  startDate: DateTime
  updatedAt: DateTime!
}

type CreateManyAndReturnSubtask {
  createdAt: DateTime!
  dependencies: String!
  description: String!
  details: String
  id: String!
  parentId: Int!
  parentTask: Task!
  status: String!
  testStrategy: String
  title: String!
  updatedAt: DateTime!
}

type CreateManyAndReturnSyncConflict {
  cliVersion: String!
  id: String!
  operationType: String!
  resolution: String
  resolved: Boolean!
  resolvedAt: DateTime
  resolvedBy: String
  taskId: String!
  timestamp: DateTime!
  uiVersion: String!
}

type CreateManyAndReturnSyncOperation {
  completedAt: DateTime
  data: String!
  error: String
  id: String!
  maxRetries: Int!
  metadata: String
  retryCount: Int!
  rollbackData: String
  source: String!
  status: String!
  taskIds: String!
  timestamp: DateTime!
  type: String!
}

type CreateManyAndReturnTask {
  complexity: Int
  createdAt: DateTime!
  description: String!
  details: String
  id: Int!
  priority: String!
  status: String!
  testStrategy: String
  title: String!
  updatedAt: DateTime!
}

type CreateManyAndReturnTaskDependency {
  createdAt: DateTime!
  dependsOn: Task!
  dependsOnId: Int!
  id: Int!
  task: Task!
  taskId: Int!
}

type CreateManyAndReturnTaskMasterMetadata {
  created: DateTime!
  description: String!
  id: Int!
  updated: DateTime!
}

type CreateManyAndReturnTeam {
  color: String!
  createdAt: DateTime!
  icon: String!
  id: String!
  joined: Boolean!
  name: String!
  updatedAt: DateTime!
}

type CreateManyAndReturnTeamMember {
  id: String!
  team: Team!
  teamId: String!
  user: User!
  userId: String!
}

type CreateManyAndReturnTeamProject {
  id: String!
  project: Project!
  projectId: String!
  team: Team!
  teamId: String!
}

type CreateManyAndReturnUser {
  avatarUrl: String
  createdAt: DateTime!
  email: String!
  id: String!
  joinedDate: DateTime!
  name: String!
  role: String!
  status: String!
  teamIds: String!
  updatedAt: DateTime!
}

type Cycle {
  _count: CycleCount
  createdAt: DateTime!
  endDate: DateTime!
  id: String!
  name: String!
  number: Int!
  progress: Int!
  startDate: DateTime!
  teamId: String!
  updatedAt: DateTime!
}

type CycleAvgAggregate {
  number: Float
  progress: Float
}

input CycleAvgOrderByAggregateInput {
  number: SortOrder
  progress: SortOrder
}

type CycleCount {
  issues(where: IssueWhereInput): Int!
}

type CycleCountAggregate {
  _all: Int!
  createdAt: Int!
  endDate: Int!
  id: Int!
  name: Int!
  number: Int!
  progress: Int!
  startDate: Int!
  teamId: Int!
  updatedAt: Int!
}

input CycleCountOrderByAggregateInput {
  createdAt: SortOrder
  endDate: SortOrder
  id: SortOrder
  name: SortOrder
  number: SortOrder
  progress: SortOrder
  startDate: SortOrder
  teamId: SortOrder
  updatedAt: SortOrder
}

input CycleCreateInput {
  createdAt: DateTime
  endDate: DateTime!
  id: String
  issues: IssueCreateNestedManyWithoutCycleInput
  name: String!
  number: Int!
  progress: Int
  startDate: DateTime!
  team: TeamCreateNestedOneWithoutCyclesInput!
  updatedAt: DateTime
}

input CycleCreateManyInput {
  createdAt: DateTime
  endDate: DateTime!
  id: String
  name: String!
  number: Int!
  progress: Int
  startDate: DateTime!
  teamId: String!
  updatedAt: DateTime
}

input CycleCreateManyTeamInput {
  createdAt: DateTime
  endDate: DateTime!
  id: String
  name: String!
  number: Int!
  progress: Int
  startDate: DateTime!
  updatedAt: DateTime
}

input CycleCreateManyTeamInputEnvelope {
  data: [CycleCreateManyTeamInput!]!
}

input CycleCreateNestedManyWithoutTeamInput {
  connect: [CycleWhereUniqueInput!]
  connectOrCreate: [CycleCreateOrConnectWithoutTeamInput!]
  create: [CycleCreateWithoutTeamInput!]
  createMany: CycleCreateManyTeamInputEnvelope
}

input CycleCreateNestedOneWithoutIssuesInput {
  connect: CycleWhereUniqueInput
  connectOrCreate: CycleCreateOrConnectWithoutIssuesInput
  create: CycleCreateWithoutIssuesInput
}

input CycleCreateOrConnectWithoutIssuesInput {
  create: CycleCreateWithoutIssuesInput!
  where: CycleWhereUniqueInput!
}

input CycleCreateOrConnectWithoutTeamInput {
  create: CycleCreateWithoutTeamInput!
  where: CycleWhereUniqueInput!
}

input CycleCreateWithoutIssuesInput {
  createdAt: DateTime
  endDate: DateTime!
  id: String
  name: String!
  number: Int!
  progress: Int
  startDate: DateTime!
  team: TeamCreateNestedOneWithoutCyclesInput!
  updatedAt: DateTime
}

input CycleCreateWithoutTeamInput {
  createdAt: DateTime
  endDate: DateTime!
  id: String
  issues: IssueCreateNestedManyWithoutCycleInput
  name: String!
  number: Int!
  progress: Int
  startDate: DateTime!
  updatedAt: DateTime
}

type CycleGroupBy {
  _avg: CycleAvgAggregate
  _count: CycleCountAggregate
  _max: CycleMaxAggregate
  _min: CycleMinAggregate
  _sum: CycleSumAggregate
  createdAt: DateTime!
  endDate: DateTime!
  id: String!
  name: String!
  number: Int!
  progress: Int!
  startDate: DateTime!
  teamId: String!
  updatedAt: DateTime!
}

input CycleListRelationFilter {
  every: CycleWhereInput
  none: CycleWhereInput
  some: CycleWhereInput
}

type CycleMaxAggregate {
  createdAt: DateTime
  endDate: DateTime
  id: String
  name: String
  number: Int
  progress: Int
  startDate: DateTime
  teamId: String
  updatedAt: DateTime
}

input CycleMaxOrderByAggregateInput {
  createdAt: SortOrder
  endDate: SortOrder
  id: SortOrder
  name: SortOrder
  number: SortOrder
  progress: SortOrder
  startDate: SortOrder
  teamId: SortOrder
  updatedAt: SortOrder
}

type CycleMinAggregate {
  createdAt: DateTime
  endDate: DateTime
  id: String
  name: String
  number: Int
  progress: Int
  startDate: DateTime
  teamId: String
  updatedAt: DateTime
}

input CycleMinOrderByAggregateInput {
  createdAt: SortOrder
  endDate: SortOrder
  id: SortOrder
  name: SortOrder
  number: SortOrder
  progress: SortOrder
  startDate: SortOrder
  teamId: SortOrder
  updatedAt: SortOrder
}

input CycleNullableRelationFilter {
  is: CycleWhereInput
  isNot: CycleWhereInput
}

input CycleOrderByRelationAggregateInput {
  _count: SortOrder
}

input CycleOrderByWithAggregationInput {
  _avg: CycleAvgOrderByAggregateInput
  _count: CycleCountOrderByAggregateInput
  _max: CycleMaxOrderByAggregateInput
  _min: CycleMinOrderByAggregateInput
  _sum: CycleSumOrderByAggregateInput
  createdAt: SortOrder
  endDate: SortOrder
  id: SortOrder
  name: SortOrder
  number: SortOrder
  progress: SortOrder
  startDate: SortOrder
  teamId: SortOrder
  updatedAt: SortOrder
}

input CycleOrderByWithRelationInput {
  createdAt: SortOrder
  endDate: SortOrder
  id: SortOrder
  issues: IssueOrderByRelationAggregateInput
  name: SortOrder
  number: SortOrder
  progress: SortOrder
  startDate: SortOrder
  team: TeamOrderByWithRelationInput
  teamId: SortOrder
  updatedAt: SortOrder
}

enum CycleScalarFieldEnum {
  createdAt
  endDate
  id
  name
  number
  progress
  startDate
  teamId
  updatedAt
}

input CycleScalarWhereInput {
  AND: [CycleScalarWhereInput!]
  NOT: [CycleScalarWhereInput!]
  OR: [CycleScalarWhereInput!]
  createdAt: DateTimeFilter
  endDate: DateTimeFilter
  id: StringFilter
  name: StringFilter
  number: IntFilter
  progress: IntFilter
  startDate: DateTimeFilter
  teamId: StringFilter
  updatedAt: DateTimeFilter
}

input CycleScalarWhereWithAggregatesInput {
  AND: [CycleScalarWhereWithAggregatesInput!]
  NOT: [CycleScalarWhereWithAggregatesInput!]
  OR: [CycleScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  endDate: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  number: IntWithAggregatesFilter
  progress: IntWithAggregatesFilter
  startDate: DateTimeWithAggregatesFilter
  teamId: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type CycleSumAggregate {
  number: Int
  progress: Int
}

input CycleSumOrderByAggregateInput {
  number: SortOrder
  progress: SortOrder
}

input CycleUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  endDate: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  issues: IssueUpdateManyWithoutCycleNestedInput
  name: StringFieldUpdateOperationsInput
  number: IntFieldUpdateOperationsInput
  progress: IntFieldUpdateOperationsInput
  startDate: DateTimeFieldUpdateOperationsInput
  team: TeamUpdateOneRequiredWithoutCyclesNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CycleUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  endDate: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  number: IntFieldUpdateOperationsInput
  progress: IntFieldUpdateOperationsInput
  startDate: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CycleUpdateManyWithWhereWithoutTeamInput {
  data: CycleUpdateManyMutationInput!
  where: CycleScalarWhereInput!
}

input CycleUpdateManyWithoutTeamNestedInput {
  connect: [CycleWhereUniqueInput!]
  connectOrCreate: [CycleCreateOrConnectWithoutTeamInput!]
  create: [CycleCreateWithoutTeamInput!]
  createMany: CycleCreateManyTeamInputEnvelope
  delete: [CycleWhereUniqueInput!]
  deleteMany: [CycleScalarWhereInput!]
  disconnect: [CycleWhereUniqueInput!]
  set: [CycleWhereUniqueInput!]
  update: [CycleUpdateWithWhereUniqueWithoutTeamInput!]
  updateMany: [CycleUpdateManyWithWhereWithoutTeamInput!]
  upsert: [CycleUpsertWithWhereUniqueWithoutTeamInput!]
}

input CycleUpdateOneWithoutIssuesNestedInput {
  connect: CycleWhereUniqueInput
  connectOrCreate: CycleCreateOrConnectWithoutIssuesInput
  create: CycleCreateWithoutIssuesInput
  delete: CycleWhereInput
  disconnect: CycleWhereInput
  update: CycleUpdateToOneWithWhereWithoutIssuesInput
  upsert: CycleUpsertWithoutIssuesInput
}

input CycleUpdateToOneWithWhereWithoutIssuesInput {
  data: CycleUpdateWithoutIssuesInput!
  where: CycleWhereInput
}

input CycleUpdateWithWhereUniqueWithoutTeamInput {
  data: CycleUpdateWithoutTeamInput!
  where: CycleWhereUniqueInput!
}

input CycleUpdateWithoutIssuesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  endDate: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  number: IntFieldUpdateOperationsInput
  progress: IntFieldUpdateOperationsInput
  startDate: DateTimeFieldUpdateOperationsInput
  team: TeamUpdateOneRequiredWithoutCyclesNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CycleUpdateWithoutTeamInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  endDate: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  issues: IssueUpdateManyWithoutCycleNestedInput
  name: StringFieldUpdateOperationsInput
  number: IntFieldUpdateOperationsInput
  progress: IntFieldUpdateOperationsInput
  startDate: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CycleUpsertWithWhereUniqueWithoutTeamInput {
  create: CycleCreateWithoutTeamInput!
  update: CycleUpdateWithoutTeamInput!
  where: CycleWhereUniqueInput!
}

input CycleUpsertWithoutIssuesInput {
  create: CycleCreateWithoutIssuesInput!
  update: CycleUpdateWithoutIssuesInput!
  where: CycleWhereInput
}

input CycleWhereInput {
  AND: [CycleWhereInput!]
  NOT: [CycleWhereInput!]
  OR: [CycleWhereInput!]
  createdAt: DateTimeFilter
  endDate: DateTimeFilter
  id: StringFilter
  issues: IssueListRelationFilter
  name: StringFilter
  number: IntFilter
  progress: IntFilter
  startDate: DateTimeFilter
  team: TeamRelationFilter
  teamId: StringFilter
  updatedAt: DateTimeFilter
}

input CycleWhereUniqueInput {
  AND: [CycleWhereInput!]
  NOT: [CycleWhereInput!]
  OR: [CycleWhereInput!]
  createdAt: DateTimeFilter
  endDate: DateTimeFilter
  id: String
  issues: IssueListRelationFilter
  name: StringFilter
  number: IntFilter
  progress: IntFilter
  startDate: DateTimeFilter
  team: TeamRelationFilter
  teamId: StringFilter
  updatedAt: DateTimeFilter
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Issue {
  _count: IssueCount
  assigneeId: String
  createdAt: DateTime!
  cycleId: String
  description: String!
  dueDate: DateTime
  id: String!
  identifier: String!
  issueType: String!
  parentIssueId: String
  priority: String
  priorityId: String
  projectId: String
  rank: String!
  status: String
  statusId: String
  subtaskId: String
  taskId: Int
  title: String!
  updatedAt: DateTime!
}

type IssueAvgAggregate {
  taskId: Float
}

input IssueAvgOrderByAggregateInput {
  taskId: SortOrder
}

type IssueCount {
  labels(where: IssueLabelWhereInput): Int!
  subIssues(where: IssueWhereInput): Int!
}

type IssueCountAggregate {
  _all: Int!
  assigneeId: Int!
  createdAt: Int!
  cycleId: Int!
  description: Int!
  dueDate: Int!
  id: Int!
  identifier: Int!
  issueType: Int!
  parentIssueId: Int!
  priority: Int!
  priorityId: Int!
  projectId: Int!
  rank: Int!
  status: Int!
  statusId: Int!
  subtaskId: Int!
  taskId: Int!
  title: Int!
  updatedAt: Int!
}

input IssueCountOrderByAggregateInput {
  assigneeId: SortOrder
  createdAt: SortOrder
  cycleId: SortOrder
  description: SortOrder
  dueDate: SortOrder
  id: SortOrder
  identifier: SortOrder
  issueType: SortOrder
  parentIssueId: SortOrder
  priority: SortOrder
  priorityId: SortOrder
  projectId: SortOrder
  rank: SortOrder
  status: SortOrder
  statusId: SortOrder
  subtaskId: SortOrder
  taskId: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input IssueCreateInput {
  assignee: UserCreateNestedOneWithoutAssignedIssuesInput
  createdAt: DateTime
  cycle: CycleCreateNestedOneWithoutIssuesInput
  description: String!
  dueDate: DateTime
  id: String
  identifier: String!
  issuePriority: IssuePriorityCreateNestedOneWithoutIssuesInput
  issueStatus: IssueStatusCreateNestedOneWithoutIssuesInput
  issueType: String!
  labels: IssueLabelCreateNestedManyWithoutIssueInput
  parentIssue: IssueCreateNestedOneWithoutSubIssuesInput
  priority: String
  project: ProjectCreateNestedOneWithoutIssuesInput
  rank: String!
  status: String
  subIssues: IssueCreateNestedManyWithoutParentIssueInput
  subtask: SubtaskCreateNestedOneWithoutIssuesInput
  task: TaskCreateNestedOneWithoutIssuesInput
  title: String!
  updatedAt: DateTime
}

input IssueCreateManyAssigneeInput {
  createdAt: DateTime
  cycleId: String
  description: String!
  dueDate: DateTime
  id: String
  identifier: String!
  issueType: String!
  parentIssueId: String
  priority: String
  priorityId: String
  projectId: String
  rank: String!
  status: String
  statusId: String
  subtaskId: String
  taskId: Int
  title: String!
  updatedAt: DateTime
}

input IssueCreateManyAssigneeInputEnvelope {
  data: [IssueCreateManyAssigneeInput!]!
}

input IssueCreateManyCycleInput {
  assigneeId: String
  createdAt: DateTime
  description: String!
  dueDate: DateTime
  id: String
  identifier: String!
  issueType: String!
  parentIssueId: String
  priority: String
  priorityId: String
  projectId: String
  rank: String!
  status: String
  statusId: String
  subtaskId: String
  taskId: Int
  title: String!
  updatedAt: DateTime
}

input IssueCreateManyCycleInputEnvelope {
  data: [IssueCreateManyCycleInput!]!
}

input IssueCreateManyInput {
  assigneeId: String
  createdAt: DateTime
  cycleId: String
  description: String!
  dueDate: DateTime
  id: String
  identifier: String!
  issueType: String!
  parentIssueId: String
  priority: String
  priorityId: String
  projectId: String
  rank: String!
  status: String
  statusId: String
  subtaskId: String
  taskId: Int
  title: String!
  updatedAt: DateTime
}

input IssueCreateManyIssuePriorityInput {
  assigneeId: String
  createdAt: DateTime
  cycleId: String
  description: String!
  dueDate: DateTime
  id: String
  identifier: String!
  issueType: String!
  parentIssueId: String
  priority: String
  projectId: String
  rank: String!
  status: String
  statusId: String
  subtaskId: String
  taskId: Int
  title: String!
  updatedAt: DateTime
}

input IssueCreateManyIssuePriorityInputEnvelope {
  data: [IssueCreateManyIssuePriorityInput!]!
}

input IssueCreateManyIssueStatusInput {
  assigneeId: String
  createdAt: DateTime
  cycleId: String
  description: String!
  dueDate: DateTime
  id: String
  identifier: String!
  issueType: String!
  parentIssueId: String
  priority: String
  priorityId: String
  projectId: String
  rank: String!
  status: String
  subtaskId: String
  taskId: Int
  title: String!
  updatedAt: DateTime
}

input IssueCreateManyIssueStatusInputEnvelope {
  data: [IssueCreateManyIssueStatusInput!]!
}

input IssueCreateManyParentIssueInput {
  assigneeId: String
  createdAt: DateTime
  cycleId: String
  description: String!
  dueDate: DateTime
  id: String
  identifier: String!
  issueType: String!
  priority: String
  priorityId: String
  projectId: String
  rank: String!
  status: String
  statusId: String
  subtaskId: String
  taskId: Int
  title: String!
  updatedAt: DateTime
}

input IssueCreateManyParentIssueInputEnvelope {
  data: [IssueCreateManyParentIssueInput!]!
}

input IssueCreateManyProjectInput {
  assigneeId: String
  createdAt: DateTime
  cycleId: String
  description: String!
  dueDate: DateTime
  id: String
  identifier: String!
  issueType: String!
  parentIssueId: String
  priority: String
  priorityId: String
  rank: String!
  status: String
  statusId: String
  subtaskId: String
  taskId: Int
  title: String!
  updatedAt: DateTime
}

input IssueCreateManyProjectInputEnvelope {
  data: [IssueCreateManyProjectInput!]!
}

input IssueCreateManySubtaskInput {
  assigneeId: String
  createdAt: DateTime
  cycleId: String
  description: String!
  dueDate: DateTime
  id: String
  identifier: String!
  issueType: String!
  parentIssueId: String
  priority: String
  priorityId: String
  projectId: String
  rank: String!
  status: String
  statusId: String
  taskId: Int
  title: String!
  updatedAt: DateTime
}

input IssueCreateManySubtaskInputEnvelope {
  data: [IssueCreateManySubtaskInput!]!
}

input IssueCreateManyTaskInput {
  assigneeId: String
  createdAt: DateTime
  cycleId: String
  description: String!
  dueDate: DateTime
  id: String
  identifier: String!
  issueType: String!
  parentIssueId: String
  priority: String
  priorityId: String
  projectId: String
  rank: String!
  status: String
  statusId: String
  subtaskId: String
  title: String!
  updatedAt: DateTime
}

input IssueCreateManyTaskInputEnvelope {
  data: [IssueCreateManyTaskInput!]!
}

input IssueCreateNestedManyWithoutAssigneeInput {
  connect: [IssueWhereUniqueInput!]
  connectOrCreate: [IssueCreateOrConnectWithoutAssigneeInput!]
  create: [IssueCreateWithoutAssigneeInput!]
  createMany: IssueCreateManyAssigneeInputEnvelope
}

input IssueCreateNestedManyWithoutCycleInput {
  connect: [IssueWhereUniqueInput!]
  connectOrCreate: [IssueCreateOrConnectWithoutCycleInput!]
  create: [IssueCreateWithoutCycleInput!]
  createMany: IssueCreateManyCycleInputEnvelope
}

input IssueCreateNestedManyWithoutIssuePriorityInput {
  connect: [IssueWhereUniqueInput!]
  connectOrCreate: [IssueCreateOrConnectWithoutIssuePriorityInput!]
  create: [IssueCreateWithoutIssuePriorityInput!]
  createMany: IssueCreateManyIssuePriorityInputEnvelope
}

input IssueCreateNestedManyWithoutIssueStatusInput {
  connect: [IssueWhereUniqueInput!]
  connectOrCreate: [IssueCreateOrConnectWithoutIssueStatusInput!]
  create: [IssueCreateWithoutIssueStatusInput!]
  createMany: IssueCreateManyIssueStatusInputEnvelope
}

input IssueCreateNestedManyWithoutParentIssueInput {
  connect: [IssueWhereUniqueInput!]
  connectOrCreate: [IssueCreateOrConnectWithoutParentIssueInput!]
  create: [IssueCreateWithoutParentIssueInput!]
  createMany: IssueCreateManyParentIssueInputEnvelope
}

input IssueCreateNestedManyWithoutProjectInput {
  connect: [IssueWhereUniqueInput!]
  connectOrCreate: [IssueCreateOrConnectWithoutProjectInput!]
  create: [IssueCreateWithoutProjectInput!]
  createMany: IssueCreateManyProjectInputEnvelope
}

input IssueCreateNestedManyWithoutSubtaskInput {
  connect: [IssueWhereUniqueInput!]
  connectOrCreate: [IssueCreateOrConnectWithoutSubtaskInput!]
  create: [IssueCreateWithoutSubtaskInput!]
  createMany: IssueCreateManySubtaskInputEnvelope
}

input IssueCreateNestedManyWithoutTaskInput {
  connect: [IssueWhereUniqueInput!]
  connectOrCreate: [IssueCreateOrConnectWithoutTaskInput!]
  create: [IssueCreateWithoutTaskInput!]
  createMany: IssueCreateManyTaskInputEnvelope
}

input IssueCreateNestedOneWithoutLabelsInput {
  connect: IssueWhereUniqueInput
  connectOrCreate: IssueCreateOrConnectWithoutLabelsInput
  create: IssueCreateWithoutLabelsInput
}

input IssueCreateNestedOneWithoutSubIssuesInput {
  connect: IssueWhereUniqueInput
  connectOrCreate: IssueCreateOrConnectWithoutSubIssuesInput
  create: IssueCreateWithoutSubIssuesInput
}

input IssueCreateOrConnectWithoutAssigneeInput {
  create: IssueCreateWithoutAssigneeInput!
  where: IssueWhereUniqueInput!
}

input IssueCreateOrConnectWithoutCycleInput {
  create: IssueCreateWithoutCycleInput!
  where: IssueWhereUniqueInput!
}

input IssueCreateOrConnectWithoutIssuePriorityInput {
  create: IssueCreateWithoutIssuePriorityInput!
  where: IssueWhereUniqueInput!
}

input IssueCreateOrConnectWithoutIssueStatusInput {
  create: IssueCreateWithoutIssueStatusInput!
  where: IssueWhereUniqueInput!
}

input IssueCreateOrConnectWithoutLabelsInput {
  create: IssueCreateWithoutLabelsInput!
  where: IssueWhereUniqueInput!
}

input IssueCreateOrConnectWithoutParentIssueInput {
  create: IssueCreateWithoutParentIssueInput!
  where: IssueWhereUniqueInput!
}

input IssueCreateOrConnectWithoutProjectInput {
  create: IssueCreateWithoutProjectInput!
  where: IssueWhereUniqueInput!
}

input IssueCreateOrConnectWithoutSubIssuesInput {
  create: IssueCreateWithoutSubIssuesInput!
  where: IssueWhereUniqueInput!
}

input IssueCreateOrConnectWithoutSubtaskInput {
  create: IssueCreateWithoutSubtaskInput!
  where: IssueWhereUniqueInput!
}

input IssueCreateOrConnectWithoutTaskInput {
  create: IssueCreateWithoutTaskInput!
  where: IssueWhereUniqueInput!
}

input IssueCreateWithoutAssigneeInput {
  createdAt: DateTime
  cycle: CycleCreateNestedOneWithoutIssuesInput
  description: String!
  dueDate: DateTime
  id: String
  identifier: String!
  issuePriority: IssuePriorityCreateNestedOneWithoutIssuesInput
  issueStatus: IssueStatusCreateNestedOneWithoutIssuesInput
  issueType: String!
  labels: IssueLabelCreateNestedManyWithoutIssueInput
  parentIssue: IssueCreateNestedOneWithoutSubIssuesInput
  priority: String
  project: ProjectCreateNestedOneWithoutIssuesInput
  rank: String!
  status: String
  subIssues: IssueCreateNestedManyWithoutParentIssueInput
  subtask: SubtaskCreateNestedOneWithoutIssuesInput
  task: TaskCreateNestedOneWithoutIssuesInput
  title: String!
  updatedAt: DateTime
}

input IssueCreateWithoutCycleInput {
  assignee: UserCreateNestedOneWithoutAssignedIssuesInput
  createdAt: DateTime
  description: String!
  dueDate: DateTime
  id: String
  identifier: String!
  issuePriority: IssuePriorityCreateNestedOneWithoutIssuesInput
  issueStatus: IssueStatusCreateNestedOneWithoutIssuesInput
  issueType: String!
  labels: IssueLabelCreateNestedManyWithoutIssueInput
  parentIssue: IssueCreateNestedOneWithoutSubIssuesInput
  priority: String
  project: ProjectCreateNestedOneWithoutIssuesInput
  rank: String!
  status: String
  subIssues: IssueCreateNestedManyWithoutParentIssueInput
  subtask: SubtaskCreateNestedOneWithoutIssuesInput
  task: TaskCreateNestedOneWithoutIssuesInput
  title: String!
  updatedAt: DateTime
}

input IssueCreateWithoutIssuePriorityInput {
  assignee: UserCreateNestedOneWithoutAssignedIssuesInput
  createdAt: DateTime
  cycle: CycleCreateNestedOneWithoutIssuesInput
  description: String!
  dueDate: DateTime
  id: String
  identifier: String!
  issueStatus: IssueStatusCreateNestedOneWithoutIssuesInput
  issueType: String!
  labels: IssueLabelCreateNestedManyWithoutIssueInput
  parentIssue: IssueCreateNestedOneWithoutSubIssuesInput
  priority: String
  project: ProjectCreateNestedOneWithoutIssuesInput
  rank: String!
  status: String
  subIssues: IssueCreateNestedManyWithoutParentIssueInput
  subtask: SubtaskCreateNestedOneWithoutIssuesInput
  task: TaskCreateNestedOneWithoutIssuesInput
  title: String!
  updatedAt: DateTime
}

input IssueCreateWithoutIssueStatusInput {
  assignee: UserCreateNestedOneWithoutAssignedIssuesInput
  createdAt: DateTime
  cycle: CycleCreateNestedOneWithoutIssuesInput
  description: String!
  dueDate: DateTime
  id: String
  identifier: String!
  issuePriority: IssuePriorityCreateNestedOneWithoutIssuesInput
  issueType: String!
  labels: IssueLabelCreateNestedManyWithoutIssueInput
  parentIssue: IssueCreateNestedOneWithoutSubIssuesInput
  priority: String
  project: ProjectCreateNestedOneWithoutIssuesInput
  rank: String!
  status: String
  subIssues: IssueCreateNestedManyWithoutParentIssueInput
  subtask: SubtaskCreateNestedOneWithoutIssuesInput
  task: TaskCreateNestedOneWithoutIssuesInput
  title: String!
  updatedAt: DateTime
}

input IssueCreateWithoutLabelsInput {
  assignee: UserCreateNestedOneWithoutAssignedIssuesInput
  createdAt: DateTime
  cycle: CycleCreateNestedOneWithoutIssuesInput
  description: String!
  dueDate: DateTime
  id: String
  identifier: String!
  issuePriority: IssuePriorityCreateNestedOneWithoutIssuesInput
  issueStatus: IssueStatusCreateNestedOneWithoutIssuesInput
  issueType: String!
  parentIssue: IssueCreateNestedOneWithoutSubIssuesInput
  priority: String
  project: ProjectCreateNestedOneWithoutIssuesInput
  rank: String!
  status: String
  subIssues: IssueCreateNestedManyWithoutParentIssueInput
  subtask: SubtaskCreateNestedOneWithoutIssuesInput
  task: TaskCreateNestedOneWithoutIssuesInput
  title: String!
  updatedAt: DateTime
}

input IssueCreateWithoutParentIssueInput {
  assignee: UserCreateNestedOneWithoutAssignedIssuesInput
  createdAt: DateTime
  cycle: CycleCreateNestedOneWithoutIssuesInput
  description: String!
  dueDate: DateTime
  id: String
  identifier: String!
  issuePriority: IssuePriorityCreateNestedOneWithoutIssuesInput
  issueStatus: IssueStatusCreateNestedOneWithoutIssuesInput
  issueType: String!
  labels: IssueLabelCreateNestedManyWithoutIssueInput
  priority: String
  project: ProjectCreateNestedOneWithoutIssuesInput
  rank: String!
  status: String
  subIssues: IssueCreateNestedManyWithoutParentIssueInput
  subtask: SubtaskCreateNestedOneWithoutIssuesInput
  task: TaskCreateNestedOneWithoutIssuesInput
  title: String!
  updatedAt: DateTime
}

input IssueCreateWithoutProjectInput {
  assignee: UserCreateNestedOneWithoutAssignedIssuesInput
  createdAt: DateTime
  cycle: CycleCreateNestedOneWithoutIssuesInput
  description: String!
  dueDate: DateTime
  id: String
  identifier: String!
  issuePriority: IssuePriorityCreateNestedOneWithoutIssuesInput
  issueStatus: IssueStatusCreateNestedOneWithoutIssuesInput
  issueType: String!
  labels: IssueLabelCreateNestedManyWithoutIssueInput
  parentIssue: IssueCreateNestedOneWithoutSubIssuesInput
  priority: String
  rank: String!
  status: String
  subIssues: IssueCreateNestedManyWithoutParentIssueInput
  subtask: SubtaskCreateNestedOneWithoutIssuesInput
  task: TaskCreateNestedOneWithoutIssuesInput
  title: String!
  updatedAt: DateTime
}

input IssueCreateWithoutSubIssuesInput {
  assignee: UserCreateNestedOneWithoutAssignedIssuesInput
  createdAt: DateTime
  cycle: CycleCreateNestedOneWithoutIssuesInput
  description: String!
  dueDate: DateTime
  id: String
  identifier: String!
  issuePriority: IssuePriorityCreateNestedOneWithoutIssuesInput
  issueStatus: IssueStatusCreateNestedOneWithoutIssuesInput
  issueType: String!
  labels: IssueLabelCreateNestedManyWithoutIssueInput
  parentIssue: IssueCreateNestedOneWithoutSubIssuesInput
  priority: String
  project: ProjectCreateNestedOneWithoutIssuesInput
  rank: String!
  status: String
  subtask: SubtaskCreateNestedOneWithoutIssuesInput
  task: TaskCreateNestedOneWithoutIssuesInput
  title: String!
  updatedAt: DateTime
}

input IssueCreateWithoutSubtaskInput {
  assignee: UserCreateNestedOneWithoutAssignedIssuesInput
  createdAt: DateTime
  cycle: CycleCreateNestedOneWithoutIssuesInput
  description: String!
  dueDate: DateTime
  id: String
  identifier: String!
  issuePriority: IssuePriorityCreateNestedOneWithoutIssuesInput
  issueStatus: IssueStatusCreateNestedOneWithoutIssuesInput
  issueType: String!
  labels: IssueLabelCreateNestedManyWithoutIssueInput
  parentIssue: IssueCreateNestedOneWithoutSubIssuesInput
  priority: String
  project: ProjectCreateNestedOneWithoutIssuesInput
  rank: String!
  status: String
  subIssues: IssueCreateNestedManyWithoutParentIssueInput
  task: TaskCreateNestedOneWithoutIssuesInput
  title: String!
  updatedAt: DateTime
}

input IssueCreateWithoutTaskInput {
  assignee: UserCreateNestedOneWithoutAssignedIssuesInput
  createdAt: DateTime
  cycle: CycleCreateNestedOneWithoutIssuesInput
  description: String!
  dueDate: DateTime
  id: String
  identifier: String!
  issuePriority: IssuePriorityCreateNestedOneWithoutIssuesInput
  issueStatus: IssueStatusCreateNestedOneWithoutIssuesInput
  issueType: String!
  labels: IssueLabelCreateNestedManyWithoutIssueInput
  parentIssue: IssueCreateNestedOneWithoutSubIssuesInput
  priority: String
  project: ProjectCreateNestedOneWithoutIssuesInput
  rank: String!
  status: String
  subIssues: IssueCreateNestedManyWithoutParentIssueInput
  subtask: SubtaskCreateNestedOneWithoutIssuesInput
  title: String!
  updatedAt: DateTime
}

type IssueGroupBy {
  _avg: IssueAvgAggregate
  _count: IssueCountAggregate
  _max: IssueMaxAggregate
  _min: IssueMinAggregate
  _sum: IssueSumAggregate
  assigneeId: String
  createdAt: DateTime!
  cycleId: String
  description: String!
  dueDate: DateTime
  id: String!
  identifier: String!
  issueType: String!
  parentIssueId: String
  priority: String
  priorityId: String
  projectId: String
  rank: String!
  status: String
  statusId: String
  subtaskId: String
  taskId: Int
  title: String!
  updatedAt: DateTime!
}

type IssueLabel {
  id: String!
  issueId: String!
  labelId: String!
}

type IssueLabelCountAggregate {
  _all: Int!
  id: Int!
  issueId: Int!
  labelId: Int!
}

input IssueLabelCountOrderByAggregateInput {
  id: SortOrder
  issueId: SortOrder
  labelId: SortOrder
}

input IssueLabelCreateInput {
  id: String
  issue: IssueCreateNestedOneWithoutLabelsInput!
  label: LabelCreateNestedOneWithoutIssuesInput!
}

input IssueLabelCreateManyInput {
  id: String
  issueId: String!
  labelId: String!
}

input IssueLabelCreateManyIssueInput {
  id: String
  labelId: String!
}

input IssueLabelCreateManyIssueInputEnvelope {
  data: [IssueLabelCreateManyIssueInput!]!
}

input IssueLabelCreateManyLabelInput {
  id: String
  issueId: String!
}

input IssueLabelCreateManyLabelInputEnvelope {
  data: [IssueLabelCreateManyLabelInput!]!
}

input IssueLabelCreateNestedManyWithoutIssueInput {
  connect: [IssueLabelWhereUniqueInput!]
  connectOrCreate: [IssueLabelCreateOrConnectWithoutIssueInput!]
  create: [IssueLabelCreateWithoutIssueInput!]
  createMany: IssueLabelCreateManyIssueInputEnvelope
}

input IssueLabelCreateNestedManyWithoutLabelInput {
  connect: [IssueLabelWhereUniqueInput!]
  connectOrCreate: [IssueLabelCreateOrConnectWithoutLabelInput!]
  create: [IssueLabelCreateWithoutLabelInput!]
  createMany: IssueLabelCreateManyLabelInputEnvelope
}

input IssueLabelCreateOrConnectWithoutIssueInput {
  create: IssueLabelCreateWithoutIssueInput!
  where: IssueLabelWhereUniqueInput!
}

input IssueLabelCreateOrConnectWithoutLabelInput {
  create: IssueLabelCreateWithoutLabelInput!
  where: IssueLabelWhereUniqueInput!
}

input IssueLabelCreateWithoutIssueInput {
  id: String
  label: LabelCreateNestedOneWithoutIssuesInput!
}

input IssueLabelCreateWithoutLabelInput {
  id: String
  issue: IssueCreateNestedOneWithoutLabelsInput!
}

type IssueLabelGroupBy {
  _count: IssueLabelCountAggregate
  _max: IssueLabelMaxAggregate
  _min: IssueLabelMinAggregate
  id: String!
  issueId: String!
  labelId: String!
}

input IssueLabelIssueIdLabelIdCompoundUniqueInput {
  issueId: String!
  labelId: String!
}

input IssueLabelListRelationFilter {
  every: IssueLabelWhereInput
  none: IssueLabelWhereInput
  some: IssueLabelWhereInput
}

type IssueLabelMaxAggregate {
  id: String
  issueId: String
  labelId: String
}

input IssueLabelMaxOrderByAggregateInput {
  id: SortOrder
  issueId: SortOrder
  labelId: SortOrder
}

type IssueLabelMinAggregate {
  id: String
  issueId: String
  labelId: String
}

input IssueLabelMinOrderByAggregateInput {
  id: SortOrder
  issueId: SortOrder
  labelId: SortOrder
}

input IssueLabelOrderByRelationAggregateInput {
  _count: SortOrder
}

input IssueLabelOrderByWithAggregationInput {
  _count: IssueLabelCountOrderByAggregateInput
  _max: IssueLabelMaxOrderByAggregateInput
  _min: IssueLabelMinOrderByAggregateInput
  id: SortOrder
  issueId: SortOrder
  labelId: SortOrder
}

input IssueLabelOrderByWithRelationInput {
  id: SortOrder
  issue: IssueOrderByWithRelationInput
  issueId: SortOrder
  label: LabelOrderByWithRelationInput
  labelId: SortOrder
}

enum IssueLabelScalarFieldEnum {
  id
  issueId
  labelId
}

input IssueLabelScalarWhereInput {
  AND: [IssueLabelScalarWhereInput!]
  NOT: [IssueLabelScalarWhereInput!]
  OR: [IssueLabelScalarWhereInput!]
  id: StringFilter
  issueId: StringFilter
  labelId: StringFilter
}

input IssueLabelScalarWhereWithAggregatesInput {
  AND: [IssueLabelScalarWhereWithAggregatesInput!]
  NOT: [IssueLabelScalarWhereWithAggregatesInput!]
  OR: [IssueLabelScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  issueId: StringWithAggregatesFilter
  labelId: StringWithAggregatesFilter
}

input IssueLabelUpdateInput {
  id: StringFieldUpdateOperationsInput
  issue: IssueUpdateOneRequiredWithoutLabelsNestedInput
  label: LabelUpdateOneRequiredWithoutIssuesNestedInput
}

input IssueLabelUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
}

input IssueLabelUpdateManyWithWhereWithoutIssueInput {
  data: IssueLabelUpdateManyMutationInput!
  where: IssueLabelScalarWhereInput!
}

input IssueLabelUpdateManyWithWhereWithoutLabelInput {
  data: IssueLabelUpdateManyMutationInput!
  where: IssueLabelScalarWhereInput!
}

input IssueLabelUpdateManyWithoutIssueNestedInput {
  connect: [IssueLabelWhereUniqueInput!]
  connectOrCreate: [IssueLabelCreateOrConnectWithoutIssueInput!]
  create: [IssueLabelCreateWithoutIssueInput!]
  createMany: IssueLabelCreateManyIssueInputEnvelope
  delete: [IssueLabelWhereUniqueInput!]
  deleteMany: [IssueLabelScalarWhereInput!]
  disconnect: [IssueLabelWhereUniqueInput!]
  set: [IssueLabelWhereUniqueInput!]
  update: [IssueLabelUpdateWithWhereUniqueWithoutIssueInput!]
  updateMany: [IssueLabelUpdateManyWithWhereWithoutIssueInput!]
  upsert: [IssueLabelUpsertWithWhereUniqueWithoutIssueInput!]
}

input IssueLabelUpdateManyWithoutLabelNestedInput {
  connect: [IssueLabelWhereUniqueInput!]
  connectOrCreate: [IssueLabelCreateOrConnectWithoutLabelInput!]
  create: [IssueLabelCreateWithoutLabelInput!]
  createMany: IssueLabelCreateManyLabelInputEnvelope
  delete: [IssueLabelWhereUniqueInput!]
  deleteMany: [IssueLabelScalarWhereInput!]
  disconnect: [IssueLabelWhereUniqueInput!]
  set: [IssueLabelWhereUniqueInput!]
  update: [IssueLabelUpdateWithWhereUniqueWithoutLabelInput!]
  updateMany: [IssueLabelUpdateManyWithWhereWithoutLabelInput!]
  upsert: [IssueLabelUpsertWithWhereUniqueWithoutLabelInput!]
}

input IssueLabelUpdateWithWhereUniqueWithoutIssueInput {
  data: IssueLabelUpdateWithoutIssueInput!
  where: IssueLabelWhereUniqueInput!
}

input IssueLabelUpdateWithWhereUniqueWithoutLabelInput {
  data: IssueLabelUpdateWithoutLabelInput!
  where: IssueLabelWhereUniqueInput!
}

input IssueLabelUpdateWithoutIssueInput {
  id: StringFieldUpdateOperationsInput
  label: LabelUpdateOneRequiredWithoutIssuesNestedInput
}

input IssueLabelUpdateWithoutLabelInput {
  id: StringFieldUpdateOperationsInput
  issue: IssueUpdateOneRequiredWithoutLabelsNestedInput
}

input IssueLabelUpsertWithWhereUniqueWithoutIssueInput {
  create: IssueLabelCreateWithoutIssueInput!
  update: IssueLabelUpdateWithoutIssueInput!
  where: IssueLabelWhereUniqueInput!
}

input IssueLabelUpsertWithWhereUniqueWithoutLabelInput {
  create: IssueLabelCreateWithoutLabelInput!
  update: IssueLabelUpdateWithoutLabelInput!
  where: IssueLabelWhereUniqueInput!
}

input IssueLabelWhereInput {
  AND: [IssueLabelWhereInput!]
  NOT: [IssueLabelWhereInput!]
  OR: [IssueLabelWhereInput!]
  id: StringFilter
  issue: IssueRelationFilter
  issueId: StringFilter
  label: LabelRelationFilter
  labelId: StringFilter
}

input IssueLabelWhereUniqueInput {
  AND: [IssueLabelWhereInput!]
  NOT: [IssueLabelWhereInput!]
  OR: [IssueLabelWhereInput!]
  id: String
  issue: IssueRelationFilter
  issueId: StringFilter
  issueId_labelId: IssueLabelIssueIdLabelIdCompoundUniqueInput
  label: LabelRelationFilter
  labelId: StringFilter
}

input IssueListRelationFilter {
  every: IssueWhereInput
  none: IssueWhereInput
  some: IssueWhereInput
}

type IssueMaxAggregate {
  assigneeId: String
  createdAt: DateTime
  cycleId: String
  description: String
  dueDate: DateTime
  id: String
  identifier: String
  issueType: String
  parentIssueId: String
  priority: String
  priorityId: String
  projectId: String
  rank: String
  status: String
  statusId: String
  subtaskId: String
  taskId: Int
  title: String
  updatedAt: DateTime
}

input IssueMaxOrderByAggregateInput {
  assigneeId: SortOrder
  createdAt: SortOrder
  cycleId: SortOrder
  description: SortOrder
  dueDate: SortOrder
  id: SortOrder
  identifier: SortOrder
  issueType: SortOrder
  parentIssueId: SortOrder
  priority: SortOrder
  priorityId: SortOrder
  projectId: SortOrder
  rank: SortOrder
  status: SortOrder
  statusId: SortOrder
  subtaskId: SortOrder
  taskId: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

type IssueMinAggregate {
  assigneeId: String
  createdAt: DateTime
  cycleId: String
  description: String
  dueDate: DateTime
  id: String
  identifier: String
  issueType: String
  parentIssueId: String
  priority: String
  priorityId: String
  projectId: String
  rank: String
  status: String
  statusId: String
  subtaskId: String
  taskId: Int
  title: String
  updatedAt: DateTime
}

input IssueMinOrderByAggregateInput {
  assigneeId: SortOrder
  createdAt: SortOrder
  cycleId: SortOrder
  description: SortOrder
  dueDate: SortOrder
  id: SortOrder
  identifier: SortOrder
  issueType: SortOrder
  parentIssueId: SortOrder
  priority: SortOrder
  priorityId: SortOrder
  projectId: SortOrder
  rank: SortOrder
  status: SortOrder
  statusId: SortOrder
  subtaskId: SortOrder
  taskId: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input IssueNullableRelationFilter {
  is: IssueWhereInput
  isNot: IssueWhereInput
}

input IssueOrderByRelationAggregateInput {
  _count: SortOrder
}

input IssueOrderByWithAggregationInput {
  _avg: IssueAvgOrderByAggregateInput
  _count: IssueCountOrderByAggregateInput
  _max: IssueMaxOrderByAggregateInput
  _min: IssueMinOrderByAggregateInput
  _sum: IssueSumOrderByAggregateInput
  assigneeId: SortOrderInput
  createdAt: SortOrder
  cycleId: SortOrderInput
  description: SortOrder
  dueDate: SortOrderInput
  id: SortOrder
  identifier: SortOrder
  issueType: SortOrder
  parentIssueId: SortOrderInput
  priority: SortOrderInput
  priorityId: SortOrderInput
  projectId: SortOrderInput
  rank: SortOrder
  status: SortOrderInput
  statusId: SortOrderInput
  subtaskId: SortOrderInput
  taskId: SortOrderInput
  title: SortOrder
  updatedAt: SortOrder
}

input IssueOrderByWithRelationInput {
  assignee: UserOrderByWithRelationInput
  assigneeId: SortOrderInput
  createdAt: SortOrder
  cycle: CycleOrderByWithRelationInput
  cycleId: SortOrderInput
  description: SortOrder
  dueDate: SortOrderInput
  id: SortOrder
  identifier: SortOrder
  issuePriority: IssuePriorityOrderByWithRelationInput
  issueStatus: IssueStatusOrderByWithRelationInput
  issueType: SortOrder
  labels: IssueLabelOrderByRelationAggregateInput
  parentIssue: IssueOrderByWithRelationInput
  parentIssueId: SortOrderInput
  priority: SortOrderInput
  priorityId: SortOrderInput
  project: ProjectOrderByWithRelationInput
  projectId: SortOrderInput
  rank: SortOrder
  status: SortOrderInput
  statusId: SortOrderInput
  subIssues: IssueOrderByRelationAggregateInput
  subtask: SubtaskOrderByWithRelationInput
  subtaskId: SortOrderInput
  task: TaskOrderByWithRelationInput
  taskId: SortOrderInput
  title: SortOrder
  updatedAt: SortOrder
}

type IssuePriority {
  _count: IssuePriorityCount
  createdAt: DateTime!
  iconName: String!
  id: String!
  name: String!
  order: Int!
  updatedAt: DateTime!
}

type IssuePriorityAvgAggregate {
  order: Float
}

input IssuePriorityAvgOrderByAggregateInput {
  order: SortOrder
}

type IssuePriorityCount {
  issues(where: IssueWhereInput): Int!
}

type IssuePriorityCountAggregate {
  _all: Int!
  createdAt: Int!
  iconName: Int!
  id: Int!
  name: Int!
  order: Int!
  updatedAt: Int!
}

input IssuePriorityCountOrderByAggregateInput {
  createdAt: SortOrder
  iconName: SortOrder
  id: SortOrder
  name: SortOrder
  order: SortOrder
  updatedAt: SortOrder
}

input IssuePriorityCreateInput {
  createdAt: DateTime
  iconName: String!
  id: String!
  issues: IssueCreateNestedManyWithoutIssuePriorityInput
  name: String!
  order: Int!
  updatedAt: DateTime
}

input IssuePriorityCreateManyInput {
  createdAt: DateTime
  iconName: String!
  id: String!
  name: String!
  order: Int!
  updatedAt: DateTime
}

input IssuePriorityCreateNestedOneWithoutIssuesInput {
  connect: IssuePriorityWhereUniqueInput
  connectOrCreate: IssuePriorityCreateOrConnectWithoutIssuesInput
  create: IssuePriorityCreateWithoutIssuesInput
}

input IssuePriorityCreateOrConnectWithoutIssuesInput {
  create: IssuePriorityCreateWithoutIssuesInput!
  where: IssuePriorityWhereUniqueInput!
}

input IssuePriorityCreateWithoutIssuesInput {
  createdAt: DateTime
  iconName: String!
  id: String!
  name: String!
  order: Int!
  updatedAt: DateTime
}

type IssuePriorityGroupBy {
  _avg: IssuePriorityAvgAggregate
  _count: IssuePriorityCountAggregate
  _max: IssuePriorityMaxAggregate
  _min: IssuePriorityMinAggregate
  _sum: IssuePrioritySumAggregate
  createdAt: DateTime!
  iconName: String!
  id: String!
  name: String!
  order: Int!
  updatedAt: DateTime!
}

type IssuePriorityMaxAggregate {
  createdAt: DateTime
  iconName: String
  id: String
  name: String
  order: Int
  updatedAt: DateTime
}

input IssuePriorityMaxOrderByAggregateInput {
  createdAt: SortOrder
  iconName: SortOrder
  id: SortOrder
  name: SortOrder
  order: SortOrder
  updatedAt: SortOrder
}

type IssuePriorityMinAggregate {
  createdAt: DateTime
  iconName: String
  id: String
  name: String
  order: Int
  updatedAt: DateTime
}

input IssuePriorityMinOrderByAggregateInput {
  createdAt: SortOrder
  iconName: SortOrder
  id: SortOrder
  name: SortOrder
  order: SortOrder
  updatedAt: SortOrder
}

input IssuePriorityNullableRelationFilter {
  is: IssuePriorityWhereInput
  isNot: IssuePriorityWhereInput
}

input IssuePriorityOrderByWithAggregationInput {
  _avg: IssuePriorityAvgOrderByAggregateInput
  _count: IssuePriorityCountOrderByAggregateInput
  _max: IssuePriorityMaxOrderByAggregateInput
  _min: IssuePriorityMinOrderByAggregateInput
  _sum: IssuePrioritySumOrderByAggregateInput
  createdAt: SortOrder
  iconName: SortOrder
  id: SortOrder
  name: SortOrder
  order: SortOrder
  updatedAt: SortOrder
}

input IssuePriorityOrderByWithRelationInput {
  createdAt: SortOrder
  iconName: SortOrder
  id: SortOrder
  issues: IssueOrderByRelationAggregateInput
  name: SortOrder
  order: SortOrder
  updatedAt: SortOrder
}

enum IssuePriorityScalarFieldEnum {
  createdAt
  iconName
  id
  name
  order
  updatedAt
}

input IssuePriorityScalarWhereWithAggregatesInput {
  AND: [IssuePriorityScalarWhereWithAggregatesInput!]
  NOT: [IssuePriorityScalarWhereWithAggregatesInput!]
  OR: [IssuePriorityScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  iconName: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  order: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type IssuePrioritySumAggregate {
  order: Int
}

input IssuePrioritySumOrderByAggregateInput {
  order: SortOrder
}

input IssuePriorityUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  iconName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  issues: IssueUpdateManyWithoutIssuePriorityNestedInput
  name: StringFieldUpdateOperationsInput
  order: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input IssuePriorityUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  iconName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  order: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input IssuePriorityUpdateOneWithoutIssuesNestedInput {
  connect: IssuePriorityWhereUniqueInput
  connectOrCreate: IssuePriorityCreateOrConnectWithoutIssuesInput
  create: IssuePriorityCreateWithoutIssuesInput
  delete: IssuePriorityWhereInput
  disconnect: IssuePriorityWhereInput
  update: IssuePriorityUpdateToOneWithWhereWithoutIssuesInput
  upsert: IssuePriorityUpsertWithoutIssuesInput
}

input IssuePriorityUpdateToOneWithWhereWithoutIssuesInput {
  data: IssuePriorityUpdateWithoutIssuesInput!
  where: IssuePriorityWhereInput
}

input IssuePriorityUpdateWithoutIssuesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  iconName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  order: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input IssuePriorityUpsertWithoutIssuesInput {
  create: IssuePriorityCreateWithoutIssuesInput!
  update: IssuePriorityUpdateWithoutIssuesInput!
  where: IssuePriorityWhereInput
}

input IssuePriorityWhereInput {
  AND: [IssuePriorityWhereInput!]
  NOT: [IssuePriorityWhereInput!]
  OR: [IssuePriorityWhereInput!]
  createdAt: DateTimeFilter
  iconName: StringFilter
  id: StringFilter
  issues: IssueListRelationFilter
  name: StringFilter
  order: IntFilter
  updatedAt: DateTimeFilter
}

input IssuePriorityWhereUniqueInput {
  AND: [IssuePriorityWhereInput!]
  NOT: [IssuePriorityWhereInput!]
  OR: [IssuePriorityWhereInput!]
  createdAt: DateTimeFilter
  iconName: StringFilter
  id: String
  issues: IssueListRelationFilter
  name: StringFilter
  order: IntFilter
  updatedAt: DateTimeFilter
}

input IssueRelationFilter {
  is: IssueWhereInput
  isNot: IssueWhereInput
}

enum IssueScalarFieldEnum {
  assigneeId
  createdAt
  cycleId
  description
  dueDate
  id
  identifier
  issueType
  parentIssueId
  priority
  priorityId
  projectId
  rank
  status
  statusId
  subtaskId
  taskId
  title
  updatedAt
}

input IssueScalarWhereInput {
  AND: [IssueScalarWhereInput!]
  NOT: [IssueScalarWhereInput!]
  OR: [IssueScalarWhereInput!]
  assigneeId: StringNullableFilter
  createdAt: DateTimeFilter
  cycleId: StringNullableFilter
  description: StringFilter
  dueDate: DateTimeNullableFilter
  id: StringFilter
  identifier: StringFilter
  issueType: StringFilter
  parentIssueId: StringNullableFilter
  priority: StringNullableFilter
  priorityId: StringNullableFilter
  projectId: StringNullableFilter
  rank: StringFilter
  status: StringNullableFilter
  statusId: StringNullableFilter
  subtaskId: StringNullableFilter
  taskId: IntNullableFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input IssueScalarWhereWithAggregatesInput {
  AND: [IssueScalarWhereWithAggregatesInput!]
  NOT: [IssueScalarWhereWithAggregatesInput!]
  OR: [IssueScalarWhereWithAggregatesInput!]
  assigneeId: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  cycleId: StringNullableWithAggregatesFilter
  description: StringWithAggregatesFilter
  dueDate: DateTimeNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  identifier: StringWithAggregatesFilter
  issueType: StringWithAggregatesFilter
  parentIssueId: StringNullableWithAggregatesFilter
  priority: StringNullableWithAggregatesFilter
  priorityId: StringNullableWithAggregatesFilter
  projectId: StringNullableWithAggregatesFilter
  rank: StringWithAggregatesFilter
  status: StringNullableWithAggregatesFilter
  statusId: StringNullableWithAggregatesFilter
  subtaskId: StringNullableWithAggregatesFilter
  taskId: IntNullableWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type IssueStatus {
  _count: IssueStatusCount
  color: String!
  createdAt: DateTime!
  iconName: String!
  id: String!
  name: String!
  updatedAt: DateTime!
}

type IssueStatusCount {
  issues(where: IssueWhereInput): Int!
}

type IssueStatusCountAggregate {
  _all: Int!
  color: Int!
  createdAt: Int!
  iconName: Int!
  id: Int!
  name: Int!
  updatedAt: Int!
}

input IssueStatusCountOrderByAggregateInput {
  color: SortOrder
  createdAt: SortOrder
  iconName: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input IssueStatusCreateInput {
  color: String!
  createdAt: DateTime
  iconName: String!
  id: String!
  issues: IssueCreateNestedManyWithoutIssueStatusInput
  name: String!
  updatedAt: DateTime
}

input IssueStatusCreateManyInput {
  color: String!
  createdAt: DateTime
  iconName: String!
  id: String!
  name: String!
  updatedAt: DateTime
}

input IssueStatusCreateNestedOneWithoutIssuesInput {
  connect: IssueStatusWhereUniqueInput
  connectOrCreate: IssueStatusCreateOrConnectWithoutIssuesInput
  create: IssueStatusCreateWithoutIssuesInput
}

input IssueStatusCreateOrConnectWithoutIssuesInput {
  create: IssueStatusCreateWithoutIssuesInput!
  where: IssueStatusWhereUniqueInput!
}

input IssueStatusCreateWithoutIssuesInput {
  color: String!
  createdAt: DateTime
  iconName: String!
  id: String!
  name: String!
  updatedAt: DateTime
}

type IssueStatusGroupBy {
  _count: IssueStatusCountAggregate
  _max: IssueStatusMaxAggregate
  _min: IssueStatusMinAggregate
  color: String!
  createdAt: DateTime!
  iconName: String!
  id: String!
  name: String!
  updatedAt: DateTime!
}

type IssueStatusMaxAggregate {
  color: String
  createdAt: DateTime
  iconName: String
  id: String
  name: String
  updatedAt: DateTime
}

input IssueStatusMaxOrderByAggregateInput {
  color: SortOrder
  createdAt: SortOrder
  iconName: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

type IssueStatusMinAggregate {
  color: String
  createdAt: DateTime
  iconName: String
  id: String
  name: String
  updatedAt: DateTime
}

input IssueStatusMinOrderByAggregateInput {
  color: SortOrder
  createdAt: SortOrder
  iconName: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input IssueStatusNullableRelationFilter {
  is: IssueStatusWhereInput
  isNot: IssueStatusWhereInput
}

input IssueStatusOrderByWithAggregationInput {
  _count: IssueStatusCountOrderByAggregateInput
  _max: IssueStatusMaxOrderByAggregateInput
  _min: IssueStatusMinOrderByAggregateInput
  color: SortOrder
  createdAt: SortOrder
  iconName: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input IssueStatusOrderByWithRelationInput {
  color: SortOrder
  createdAt: SortOrder
  iconName: SortOrder
  id: SortOrder
  issues: IssueOrderByRelationAggregateInput
  name: SortOrder
  updatedAt: SortOrder
}

enum IssueStatusScalarFieldEnum {
  color
  createdAt
  iconName
  id
  name
  updatedAt
}

input IssueStatusScalarWhereWithAggregatesInput {
  AND: [IssueStatusScalarWhereWithAggregatesInput!]
  NOT: [IssueStatusScalarWhereWithAggregatesInput!]
  OR: [IssueStatusScalarWhereWithAggregatesInput!]
  color: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  iconName: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input IssueStatusUpdateInput {
  color: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  iconName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  issues: IssueUpdateManyWithoutIssueStatusNestedInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input IssueStatusUpdateManyMutationInput {
  color: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  iconName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input IssueStatusUpdateOneWithoutIssuesNestedInput {
  connect: IssueStatusWhereUniqueInput
  connectOrCreate: IssueStatusCreateOrConnectWithoutIssuesInput
  create: IssueStatusCreateWithoutIssuesInput
  delete: IssueStatusWhereInput
  disconnect: IssueStatusWhereInput
  update: IssueStatusUpdateToOneWithWhereWithoutIssuesInput
  upsert: IssueStatusUpsertWithoutIssuesInput
}

input IssueStatusUpdateToOneWithWhereWithoutIssuesInput {
  data: IssueStatusUpdateWithoutIssuesInput!
  where: IssueStatusWhereInput
}

input IssueStatusUpdateWithoutIssuesInput {
  color: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  iconName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input IssueStatusUpsertWithoutIssuesInput {
  create: IssueStatusCreateWithoutIssuesInput!
  update: IssueStatusUpdateWithoutIssuesInput!
  where: IssueStatusWhereInput
}

input IssueStatusWhereInput {
  AND: [IssueStatusWhereInput!]
  NOT: [IssueStatusWhereInput!]
  OR: [IssueStatusWhereInput!]
  color: StringFilter
  createdAt: DateTimeFilter
  iconName: StringFilter
  id: StringFilter
  issues: IssueListRelationFilter
  name: StringFilter
  updatedAt: DateTimeFilter
}

input IssueStatusWhereUniqueInput {
  AND: [IssueStatusWhereInput!]
  NOT: [IssueStatusWhereInput!]
  OR: [IssueStatusWhereInput!]
  color: StringFilter
  createdAt: DateTimeFilter
  iconName: StringFilter
  id: String
  issues: IssueListRelationFilter
  name: StringFilter
  updatedAt: DateTimeFilter
}

type IssueSumAggregate {
  taskId: Int
}

input IssueSumOrderByAggregateInput {
  taskId: SortOrder
}

input IssueUpdateInput {
  assignee: UserUpdateOneWithoutAssignedIssuesNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  cycle: CycleUpdateOneWithoutIssuesNestedInput
  description: StringFieldUpdateOperationsInput
  dueDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  issuePriority: IssuePriorityUpdateOneWithoutIssuesNestedInput
  issueStatus: IssueStatusUpdateOneWithoutIssuesNestedInput
  issueType: StringFieldUpdateOperationsInput
  labels: IssueLabelUpdateManyWithoutIssueNestedInput
  parentIssue: IssueUpdateOneWithoutSubIssuesNestedInput
  priority: NullableStringFieldUpdateOperationsInput
  project: ProjectUpdateOneWithoutIssuesNestedInput
  rank: StringFieldUpdateOperationsInput
  status: NullableStringFieldUpdateOperationsInput
  subIssues: IssueUpdateManyWithoutParentIssueNestedInput
  subtask: SubtaskUpdateOneWithoutIssuesNestedInput
  task: TaskUpdateOneWithoutIssuesNestedInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input IssueUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  dueDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  issueType: StringFieldUpdateOperationsInput
  priority: NullableStringFieldUpdateOperationsInput
  rank: StringFieldUpdateOperationsInput
  status: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input IssueUpdateManyWithWhereWithoutAssigneeInput {
  data: IssueUpdateManyMutationInput!
  where: IssueScalarWhereInput!
}

input IssueUpdateManyWithWhereWithoutCycleInput {
  data: IssueUpdateManyMutationInput!
  where: IssueScalarWhereInput!
}

input IssueUpdateManyWithWhereWithoutIssuePriorityInput {
  data: IssueUpdateManyMutationInput!
  where: IssueScalarWhereInput!
}

input IssueUpdateManyWithWhereWithoutIssueStatusInput {
  data: IssueUpdateManyMutationInput!
  where: IssueScalarWhereInput!
}

input IssueUpdateManyWithWhereWithoutParentIssueInput {
  data: IssueUpdateManyMutationInput!
  where: IssueScalarWhereInput!
}

input IssueUpdateManyWithWhereWithoutProjectInput {
  data: IssueUpdateManyMutationInput!
  where: IssueScalarWhereInput!
}

input IssueUpdateManyWithWhereWithoutSubtaskInput {
  data: IssueUpdateManyMutationInput!
  where: IssueScalarWhereInput!
}

input IssueUpdateManyWithWhereWithoutTaskInput {
  data: IssueUpdateManyMutationInput!
  where: IssueScalarWhereInput!
}

input IssueUpdateManyWithoutAssigneeNestedInput {
  connect: [IssueWhereUniqueInput!]
  connectOrCreate: [IssueCreateOrConnectWithoutAssigneeInput!]
  create: [IssueCreateWithoutAssigneeInput!]
  createMany: IssueCreateManyAssigneeInputEnvelope
  delete: [IssueWhereUniqueInput!]
  deleteMany: [IssueScalarWhereInput!]
  disconnect: [IssueWhereUniqueInput!]
  set: [IssueWhereUniqueInput!]
  update: [IssueUpdateWithWhereUniqueWithoutAssigneeInput!]
  updateMany: [IssueUpdateManyWithWhereWithoutAssigneeInput!]
  upsert: [IssueUpsertWithWhereUniqueWithoutAssigneeInput!]
}

input IssueUpdateManyWithoutCycleNestedInput {
  connect: [IssueWhereUniqueInput!]
  connectOrCreate: [IssueCreateOrConnectWithoutCycleInput!]
  create: [IssueCreateWithoutCycleInput!]
  createMany: IssueCreateManyCycleInputEnvelope
  delete: [IssueWhereUniqueInput!]
  deleteMany: [IssueScalarWhereInput!]
  disconnect: [IssueWhereUniqueInput!]
  set: [IssueWhereUniqueInput!]
  update: [IssueUpdateWithWhereUniqueWithoutCycleInput!]
  updateMany: [IssueUpdateManyWithWhereWithoutCycleInput!]
  upsert: [IssueUpsertWithWhereUniqueWithoutCycleInput!]
}

input IssueUpdateManyWithoutIssuePriorityNestedInput {
  connect: [IssueWhereUniqueInput!]
  connectOrCreate: [IssueCreateOrConnectWithoutIssuePriorityInput!]
  create: [IssueCreateWithoutIssuePriorityInput!]
  createMany: IssueCreateManyIssuePriorityInputEnvelope
  delete: [IssueWhereUniqueInput!]
  deleteMany: [IssueScalarWhereInput!]
  disconnect: [IssueWhereUniqueInput!]
  set: [IssueWhereUniqueInput!]
  update: [IssueUpdateWithWhereUniqueWithoutIssuePriorityInput!]
  updateMany: [IssueUpdateManyWithWhereWithoutIssuePriorityInput!]
  upsert: [IssueUpsertWithWhereUniqueWithoutIssuePriorityInput!]
}

input IssueUpdateManyWithoutIssueStatusNestedInput {
  connect: [IssueWhereUniqueInput!]
  connectOrCreate: [IssueCreateOrConnectWithoutIssueStatusInput!]
  create: [IssueCreateWithoutIssueStatusInput!]
  createMany: IssueCreateManyIssueStatusInputEnvelope
  delete: [IssueWhereUniqueInput!]
  deleteMany: [IssueScalarWhereInput!]
  disconnect: [IssueWhereUniqueInput!]
  set: [IssueWhereUniqueInput!]
  update: [IssueUpdateWithWhereUniqueWithoutIssueStatusInput!]
  updateMany: [IssueUpdateManyWithWhereWithoutIssueStatusInput!]
  upsert: [IssueUpsertWithWhereUniqueWithoutIssueStatusInput!]
}

input IssueUpdateManyWithoutParentIssueNestedInput {
  connect: [IssueWhereUniqueInput!]
  connectOrCreate: [IssueCreateOrConnectWithoutParentIssueInput!]
  create: [IssueCreateWithoutParentIssueInput!]
  createMany: IssueCreateManyParentIssueInputEnvelope
  delete: [IssueWhereUniqueInput!]
  deleteMany: [IssueScalarWhereInput!]
  disconnect: [IssueWhereUniqueInput!]
  set: [IssueWhereUniqueInput!]
  update: [IssueUpdateWithWhereUniqueWithoutParentIssueInput!]
  updateMany: [IssueUpdateManyWithWhereWithoutParentIssueInput!]
  upsert: [IssueUpsertWithWhereUniqueWithoutParentIssueInput!]
}

input IssueUpdateManyWithoutProjectNestedInput {
  connect: [IssueWhereUniqueInput!]
  connectOrCreate: [IssueCreateOrConnectWithoutProjectInput!]
  create: [IssueCreateWithoutProjectInput!]
  createMany: IssueCreateManyProjectInputEnvelope
  delete: [IssueWhereUniqueInput!]
  deleteMany: [IssueScalarWhereInput!]
  disconnect: [IssueWhereUniqueInput!]
  set: [IssueWhereUniqueInput!]
  update: [IssueUpdateWithWhereUniqueWithoutProjectInput!]
  updateMany: [IssueUpdateManyWithWhereWithoutProjectInput!]
  upsert: [IssueUpsertWithWhereUniqueWithoutProjectInput!]
}

input IssueUpdateManyWithoutSubtaskNestedInput {
  connect: [IssueWhereUniqueInput!]
  connectOrCreate: [IssueCreateOrConnectWithoutSubtaskInput!]
  create: [IssueCreateWithoutSubtaskInput!]
  createMany: IssueCreateManySubtaskInputEnvelope
  delete: [IssueWhereUniqueInput!]
  deleteMany: [IssueScalarWhereInput!]
  disconnect: [IssueWhereUniqueInput!]
  set: [IssueWhereUniqueInput!]
  update: [IssueUpdateWithWhereUniqueWithoutSubtaskInput!]
  updateMany: [IssueUpdateManyWithWhereWithoutSubtaskInput!]
  upsert: [IssueUpsertWithWhereUniqueWithoutSubtaskInput!]
}

input IssueUpdateManyWithoutTaskNestedInput {
  connect: [IssueWhereUniqueInput!]
  connectOrCreate: [IssueCreateOrConnectWithoutTaskInput!]
  create: [IssueCreateWithoutTaskInput!]
  createMany: IssueCreateManyTaskInputEnvelope
  delete: [IssueWhereUniqueInput!]
  deleteMany: [IssueScalarWhereInput!]
  disconnect: [IssueWhereUniqueInput!]
  set: [IssueWhereUniqueInput!]
  update: [IssueUpdateWithWhereUniqueWithoutTaskInput!]
  updateMany: [IssueUpdateManyWithWhereWithoutTaskInput!]
  upsert: [IssueUpsertWithWhereUniqueWithoutTaskInput!]
}

input IssueUpdateOneRequiredWithoutLabelsNestedInput {
  connect: IssueWhereUniqueInput
  connectOrCreate: IssueCreateOrConnectWithoutLabelsInput
  create: IssueCreateWithoutLabelsInput
  update: IssueUpdateToOneWithWhereWithoutLabelsInput
  upsert: IssueUpsertWithoutLabelsInput
}

input IssueUpdateOneWithoutSubIssuesNestedInput {
  connect: IssueWhereUniqueInput
  connectOrCreate: IssueCreateOrConnectWithoutSubIssuesInput
  create: IssueCreateWithoutSubIssuesInput
  delete: IssueWhereInput
  disconnect: IssueWhereInput
  update: IssueUpdateToOneWithWhereWithoutSubIssuesInput
  upsert: IssueUpsertWithoutSubIssuesInput
}

input IssueUpdateToOneWithWhereWithoutLabelsInput {
  data: IssueUpdateWithoutLabelsInput!
  where: IssueWhereInput
}

input IssueUpdateToOneWithWhereWithoutSubIssuesInput {
  data: IssueUpdateWithoutSubIssuesInput!
  where: IssueWhereInput
}

input IssueUpdateWithWhereUniqueWithoutAssigneeInput {
  data: IssueUpdateWithoutAssigneeInput!
  where: IssueWhereUniqueInput!
}

input IssueUpdateWithWhereUniqueWithoutCycleInput {
  data: IssueUpdateWithoutCycleInput!
  where: IssueWhereUniqueInput!
}

input IssueUpdateWithWhereUniqueWithoutIssuePriorityInput {
  data: IssueUpdateWithoutIssuePriorityInput!
  where: IssueWhereUniqueInput!
}

input IssueUpdateWithWhereUniqueWithoutIssueStatusInput {
  data: IssueUpdateWithoutIssueStatusInput!
  where: IssueWhereUniqueInput!
}

input IssueUpdateWithWhereUniqueWithoutParentIssueInput {
  data: IssueUpdateWithoutParentIssueInput!
  where: IssueWhereUniqueInput!
}

input IssueUpdateWithWhereUniqueWithoutProjectInput {
  data: IssueUpdateWithoutProjectInput!
  where: IssueWhereUniqueInput!
}

input IssueUpdateWithWhereUniqueWithoutSubtaskInput {
  data: IssueUpdateWithoutSubtaskInput!
  where: IssueWhereUniqueInput!
}

input IssueUpdateWithWhereUniqueWithoutTaskInput {
  data: IssueUpdateWithoutTaskInput!
  where: IssueWhereUniqueInput!
}

input IssueUpdateWithoutAssigneeInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  cycle: CycleUpdateOneWithoutIssuesNestedInput
  description: StringFieldUpdateOperationsInput
  dueDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  issuePriority: IssuePriorityUpdateOneWithoutIssuesNestedInput
  issueStatus: IssueStatusUpdateOneWithoutIssuesNestedInput
  issueType: StringFieldUpdateOperationsInput
  labels: IssueLabelUpdateManyWithoutIssueNestedInput
  parentIssue: IssueUpdateOneWithoutSubIssuesNestedInput
  priority: NullableStringFieldUpdateOperationsInput
  project: ProjectUpdateOneWithoutIssuesNestedInput
  rank: StringFieldUpdateOperationsInput
  status: NullableStringFieldUpdateOperationsInput
  subIssues: IssueUpdateManyWithoutParentIssueNestedInput
  subtask: SubtaskUpdateOneWithoutIssuesNestedInput
  task: TaskUpdateOneWithoutIssuesNestedInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input IssueUpdateWithoutCycleInput {
  assignee: UserUpdateOneWithoutAssignedIssuesNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  dueDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  issuePriority: IssuePriorityUpdateOneWithoutIssuesNestedInput
  issueStatus: IssueStatusUpdateOneWithoutIssuesNestedInput
  issueType: StringFieldUpdateOperationsInput
  labels: IssueLabelUpdateManyWithoutIssueNestedInput
  parentIssue: IssueUpdateOneWithoutSubIssuesNestedInput
  priority: NullableStringFieldUpdateOperationsInput
  project: ProjectUpdateOneWithoutIssuesNestedInput
  rank: StringFieldUpdateOperationsInput
  status: NullableStringFieldUpdateOperationsInput
  subIssues: IssueUpdateManyWithoutParentIssueNestedInput
  subtask: SubtaskUpdateOneWithoutIssuesNestedInput
  task: TaskUpdateOneWithoutIssuesNestedInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input IssueUpdateWithoutIssuePriorityInput {
  assignee: UserUpdateOneWithoutAssignedIssuesNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  cycle: CycleUpdateOneWithoutIssuesNestedInput
  description: StringFieldUpdateOperationsInput
  dueDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  issueStatus: IssueStatusUpdateOneWithoutIssuesNestedInput
  issueType: StringFieldUpdateOperationsInput
  labels: IssueLabelUpdateManyWithoutIssueNestedInput
  parentIssue: IssueUpdateOneWithoutSubIssuesNestedInput
  priority: NullableStringFieldUpdateOperationsInput
  project: ProjectUpdateOneWithoutIssuesNestedInput
  rank: StringFieldUpdateOperationsInput
  status: NullableStringFieldUpdateOperationsInput
  subIssues: IssueUpdateManyWithoutParentIssueNestedInput
  subtask: SubtaskUpdateOneWithoutIssuesNestedInput
  task: TaskUpdateOneWithoutIssuesNestedInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input IssueUpdateWithoutIssueStatusInput {
  assignee: UserUpdateOneWithoutAssignedIssuesNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  cycle: CycleUpdateOneWithoutIssuesNestedInput
  description: StringFieldUpdateOperationsInput
  dueDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  issuePriority: IssuePriorityUpdateOneWithoutIssuesNestedInput
  issueType: StringFieldUpdateOperationsInput
  labels: IssueLabelUpdateManyWithoutIssueNestedInput
  parentIssue: IssueUpdateOneWithoutSubIssuesNestedInput
  priority: NullableStringFieldUpdateOperationsInput
  project: ProjectUpdateOneWithoutIssuesNestedInput
  rank: StringFieldUpdateOperationsInput
  status: NullableStringFieldUpdateOperationsInput
  subIssues: IssueUpdateManyWithoutParentIssueNestedInput
  subtask: SubtaskUpdateOneWithoutIssuesNestedInput
  task: TaskUpdateOneWithoutIssuesNestedInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input IssueUpdateWithoutLabelsInput {
  assignee: UserUpdateOneWithoutAssignedIssuesNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  cycle: CycleUpdateOneWithoutIssuesNestedInput
  description: StringFieldUpdateOperationsInput
  dueDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  issuePriority: IssuePriorityUpdateOneWithoutIssuesNestedInput
  issueStatus: IssueStatusUpdateOneWithoutIssuesNestedInput
  issueType: StringFieldUpdateOperationsInput
  parentIssue: IssueUpdateOneWithoutSubIssuesNestedInput
  priority: NullableStringFieldUpdateOperationsInput
  project: ProjectUpdateOneWithoutIssuesNestedInput
  rank: StringFieldUpdateOperationsInput
  status: NullableStringFieldUpdateOperationsInput
  subIssues: IssueUpdateManyWithoutParentIssueNestedInput
  subtask: SubtaskUpdateOneWithoutIssuesNestedInput
  task: TaskUpdateOneWithoutIssuesNestedInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input IssueUpdateWithoutParentIssueInput {
  assignee: UserUpdateOneWithoutAssignedIssuesNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  cycle: CycleUpdateOneWithoutIssuesNestedInput
  description: StringFieldUpdateOperationsInput
  dueDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  issuePriority: IssuePriorityUpdateOneWithoutIssuesNestedInput
  issueStatus: IssueStatusUpdateOneWithoutIssuesNestedInput
  issueType: StringFieldUpdateOperationsInput
  labels: IssueLabelUpdateManyWithoutIssueNestedInput
  priority: NullableStringFieldUpdateOperationsInput
  project: ProjectUpdateOneWithoutIssuesNestedInput
  rank: StringFieldUpdateOperationsInput
  status: NullableStringFieldUpdateOperationsInput
  subIssues: IssueUpdateManyWithoutParentIssueNestedInput
  subtask: SubtaskUpdateOneWithoutIssuesNestedInput
  task: TaskUpdateOneWithoutIssuesNestedInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input IssueUpdateWithoutProjectInput {
  assignee: UserUpdateOneWithoutAssignedIssuesNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  cycle: CycleUpdateOneWithoutIssuesNestedInput
  description: StringFieldUpdateOperationsInput
  dueDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  issuePriority: IssuePriorityUpdateOneWithoutIssuesNestedInput
  issueStatus: IssueStatusUpdateOneWithoutIssuesNestedInput
  issueType: StringFieldUpdateOperationsInput
  labels: IssueLabelUpdateManyWithoutIssueNestedInput
  parentIssue: IssueUpdateOneWithoutSubIssuesNestedInput
  priority: NullableStringFieldUpdateOperationsInput
  rank: StringFieldUpdateOperationsInput
  status: NullableStringFieldUpdateOperationsInput
  subIssues: IssueUpdateManyWithoutParentIssueNestedInput
  subtask: SubtaskUpdateOneWithoutIssuesNestedInput
  task: TaskUpdateOneWithoutIssuesNestedInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input IssueUpdateWithoutSubIssuesInput {
  assignee: UserUpdateOneWithoutAssignedIssuesNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  cycle: CycleUpdateOneWithoutIssuesNestedInput
  description: StringFieldUpdateOperationsInput
  dueDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  issuePriority: IssuePriorityUpdateOneWithoutIssuesNestedInput
  issueStatus: IssueStatusUpdateOneWithoutIssuesNestedInput
  issueType: StringFieldUpdateOperationsInput
  labels: IssueLabelUpdateManyWithoutIssueNestedInput
  parentIssue: IssueUpdateOneWithoutSubIssuesNestedInput
  priority: NullableStringFieldUpdateOperationsInput
  project: ProjectUpdateOneWithoutIssuesNestedInput
  rank: StringFieldUpdateOperationsInput
  status: NullableStringFieldUpdateOperationsInput
  subtask: SubtaskUpdateOneWithoutIssuesNestedInput
  task: TaskUpdateOneWithoutIssuesNestedInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input IssueUpdateWithoutSubtaskInput {
  assignee: UserUpdateOneWithoutAssignedIssuesNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  cycle: CycleUpdateOneWithoutIssuesNestedInput
  description: StringFieldUpdateOperationsInput
  dueDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  issuePriority: IssuePriorityUpdateOneWithoutIssuesNestedInput
  issueStatus: IssueStatusUpdateOneWithoutIssuesNestedInput
  issueType: StringFieldUpdateOperationsInput
  labels: IssueLabelUpdateManyWithoutIssueNestedInput
  parentIssue: IssueUpdateOneWithoutSubIssuesNestedInput
  priority: NullableStringFieldUpdateOperationsInput
  project: ProjectUpdateOneWithoutIssuesNestedInput
  rank: StringFieldUpdateOperationsInput
  status: NullableStringFieldUpdateOperationsInput
  subIssues: IssueUpdateManyWithoutParentIssueNestedInput
  task: TaskUpdateOneWithoutIssuesNestedInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input IssueUpdateWithoutTaskInput {
  assignee: UserUpdateOneWithoutAssignedIssuesNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  cycle: CycleUpdateOneWithoutIssuesNestedInput
  description: StringFieldUpdateOperationsInput
  dueDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  issuePriority: IssuePriorityUpdateOneWithoutIssuesNestedInput
  issueStatus: IssueStatusUpdateOneWithoutIssuesNestedInput
  issueType: StringFieldUpdateOperationsInput
  labels: IssueLabelUpdateManyWithoutIssueNestedInput
  parentIssue: IssueUpdateOneWithoutSubIssuesNestedInput
  priority: NullableStringFieldUpdateOperationsInput
  project: ProjectUpdateOneWithoutIssuesNestedInput
  rank: StringFieldUpdateOperationsInput
  status: NullableStringFieldUpdateOperationsInput
  subIssues: IssueUpdateManyWithoutParentIssueNestedInput
  subtask: SubtaskUpdateOneWithoutIssuesNestedInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input IssueUpsertWithWhereUniqueWithoutAssigneeInput {
  create: IssueCreateWithoutAssigneeInput!
  update: IssueUpdateWithoutAssigneeInput!
  where: IssueWhereUniqueInput!
}

input IssueUpsertWithWhereUniqueWithoutCycleInput {
  create: IssueCreateWithoutCycleInput!
  update: IssueUpdateWithoutCycleInput!
  where: IssueWhereUniqueInput!
}

input IssueUpsertWithWhereUniqueWithoutIssuePriorityInput {
  create: IssueCreateWithoutIssuePriorityInput!
  update: IssueUpdateWithoutIssuePriorityInput!
  where: IssueWhereUniqueInput!
}

input IssueUpsertWithWhereUniqueWithoutIssueStatusInput {
  create: IssueCreateWithoutIssueStatusInput!
  update: IssueUpdateWithoutIssueStatusInput!
  where: IssueWhereUniqueInput!
}

input IssueUpsertWithWhereUniqueWithoutParentIssueInput {
  create: IssueCreateWithoutParentIssueInput!
  update: IssueUpdateWithoutParentIssueInput!
  where: IssueWhereUniqueInput!
}

input IssueUpsertWithWhereUniqueWithoutProjectInput {
  create: IssueCreateWithoutProjectInput!
  update: IssueUpdateWithoutProjectInput!
  where: IssueWhereUniqueInput!
}

input IssueUpsertWithWhereUniqueWithoutSubtaskInput {
  create: IssueCreateWithoutSubtaskInput!
  update: IssueUpdateWithoutSubtaskInput!
  where: IssueWhereUniqueInput!
}

input IssueUpsertWithWhereUniqueWithoutTaskInput {
  create: IssueCreateWithoutTaskInput!
  update: IssueUpdateWithoutTaskInput!
  where: IssueWhereUniqueInput!
}

input IssueUpsertWithoutLabelsInput {
  create: IssueCreateWithoutLabelsInput!
  update: IssueUpdateWithoutLabelsInput!
  where: IssueWhereInput
}

input IssueUpsertWithoutSubIssuesInput {
  create: IssueCreateWithoutSubIssuesInput!
  update: IssueUpdateWithoutSubIssuesInput!
  where: IssueWhereInput
}

input IssueWhereInput {
  AND: [IssueWhereInput!]
  NOT: [IssueWhereInput!]
  OR: [IssueWhereInput!]
  assignee: UserNullableRelationFilter
  assigneeId: StringNullableFilter
  createdAt: DateTimeFilter
  cycle: CycleNullableRelationFilter
  cycleId: StringNullableFilter
  description: StringFilter
  dueDate: DateTimeNullableFilter
  id: StringFilter
  identifier: StringFilter
  issuePriority: IssuePriorityNullableRelationFilter
  issueStatus: IssueStatusNullableRelationFilter
  issueType: StringFilter
  labels: IssueLabelListRelationFilter
  parentIssue: IssueNullableRelationFilter
  parentIssueId: StringNullableFilter
  priority: StringNullableFilter
  priorityId: StringNullableFilter
  project: ProjectNullableRelationFilter
  projectId: StringNullableFilter
  rank: StringFilter
  status: StringNullableFilter
  statusId: StringNullableFilter
  subIssues: IssueListRelationFilter
  subtask: SubtaskNullableRelationFilter
  subtaskId: StringNullableFilter
  task: TaskNullableRelationFilter
  taskId: IntNullableFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input IssueWhereUniqueInput {
  AND: [IssueWhereInput!]
  NOT: [IssueWhereInput!]
  OR: [IssueWhereInput!]
  assignee: UserNullableRelationFilter
  assigneeId: StringNullableFilter
  createdAt: DateTimeFilter
  cycle: CycleNullableRelationFilter
  cycleId: StringNullableFilter
  description: StringFilter
  dueDate: DateTimeNullableFilter
  id: String
  identifier: String
  issuePriority: IssuePriorityNullableRelationFilter
  issueStatus: IssueStatusNullableRelationFilter
  issueType: StringFilter
  labels: IssueLabelListRelationFilter
  parentIssue: IssueNullableRelationFilter
  parentIssueId: StringNullableFilter
  priority: StringNullableFilter
  priorityId: StringNullableFilter
  project: ProjectNullableRelationFilter
  projectId: StringNullableFilter
  rank: StringFilter
  status: StringNullableFilter
  statusId: StringNullableFilter
  subIssues: IssueListRelationFilter
  subtask: SubtaskNullableRelationFilter
  subtaskId: StringNullableFilter
  task: TaskNullableRelationFilter
  taskId: IntNullableFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

type Label {
  _count: LabelCount
  color: String!
  createdAt: DateTime!
  description: String
  id: String!
  name: String!
  updatedAt: DateTime!
}

type LabelCount {
  issues(where: IssueLabelWhereInput): Int!
}

type LabelCountAggregate {
  _all: Int!
  color: Int!
  createdAt: Int!
  description: Int!
  id: Int!
  name: Int!
  updatedAt: Int!
}

input LabelCountOrderByAggregateInput {
  color: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input LabelCreateInput {
  color: String!
  createdAt: DateTime
  description: String
  id: String
  issues: IssueLabelCreateNestedManyWithoutLabelInput
  name: String!
  updatedAt: DateTime
}

input LabelCreateManyInput {
  color: String!
  createdAt: DateTime
  description: String
  id: String
  name: String!
  updatedAt: DateTime
}

input LabelCreateNestedOneWithoutIssuesInput {
  connect: LabelWhereUniqueInput
  connectOrCreate: LabelCreateOrConnectWithoutIssuesInput
  create: LabelCreateWithoutIssuesInput
}

input LabelCreateOrConnectWithoutIssuesInput {
  create: LabelCreateWithoutIssuesInput!
  where: LabelWhereUniqueInput!
}

input LabelCreateWithoutIssuesInput {
  color: String!
  createdAt: DateTime
  description: String
  id: String
  name: String!
  updatedAt: DateTime
}

type LabelGroupBy {
  _count: LabelCountAggregate
  _max: LabelMaxAggregate
  _min: LabelMinAggregate
  color: String!
  createdAt: DateTime!
  description: String
  id: String!
  name: String!
  updatedAt: DateTime!
}

type LabelMaxAggregate {
  color: String
  createdAt: DateTime
  description: String
  id: String
  name: String
  updatedAt: DateTime
}

input LabelMaxOrderByAggregateInput {
  color: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

type LabelMinAggregate {
  color: String
  createdAt: DateTime
  description: String
  id: String
  name: String
  updatedAt: DateTime
}

input LabelMinOrderByAggregateInput {
  color: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input LabelOrderByWithAggregationInput {
  _count: LabelCountOrderByAggregateInput
  _max: LabelMaxOrderByAggregateInput
  _min: LabelMinOrderByAggregateInput
  color: SortOrder
  createdAt: SortOrder
  description: SortOrderInput
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input LabelOrderByWithRelationInput {
  color: SortOrder
  createdAt: SortOrder
  description: SortOrderInput
  id: SortOrder
  issues: IssueLabelOrderByRelationAggregateInput
  name: SortOrder
  updatedAt: SortOrder
}

input LabelRelationFilter {
  is: LabelWhereInput
  isNot: LabelWhereInput
}

enum LabelScalarFieldEnum {
  color
  createdAt
  description
  id
  name
  updatedAt
}

input LabelScalarWhereWithAggregatesInput {
  AND: [LabelScalarWhereWithAggregatesInput!]
  NOT: [LabelScalarWhereWithAggregatesInput!]
  OR: [LabelScalarWhereWithAggregatesInput!]
  color: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  description: StringNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input LabelUpdateInput {
  color: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  issues: IssueLabelUpdateManyWithoutLabelNestedInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LabelUpdateManyMutationInput {
  color: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LabelUpdateOneRequiredWithoutIssuesNestedInput {
  connect: LabelWhereUniqueInput
  connectOrCreate: LabelCreateOrConnectWithoutIssuesInput
  create: LabelCreateWithoutIssuesInput
  update: LabelUpdateToOneWithWhereWithoutIssuesInput
  upsert: LabelUpsertWithoutIssuesInput
}

input LabelUpdateToOneWithWhereWithoutIssuesInput {
  data: LabelUpdateWithoutIssuesInput!
  where: LabelWhereInput
}

input LabelUpdateWithoutIssuesInput {
  color: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LabelUpsertWithoutIssuesInput {
  create: LabelCreateWithoutIssuesInput!
  update: LabelUpdateWithoutIssuesInput!
  where: LabelWhereInput
}

input LabelWhereInput {
  AND: [LabelWhereInput!]
  NOT: [LabelWhereInput!]
  OR: [LabelWhereInput!]
  color: StringFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  id: StringFilter
  issues: IssueLabelListRelationFilter
  name: StringFilter
  updatedAt: DateTimeFilter
}

input LabelWhereUniqueInput {
  AND: [LabelWhereInput!]
  NOT: [LabelWhereInput!]
  OR: [LabelWhereInput!]
  color: StringFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  id: String
  issues: IssueLabelListRelationFilter
  name: StringFilter
  updatedAt: DateTimeFilter
}

type Mutation {
  createManyAndReturnCycle(data: [CycleCreateManyInput!]!): [CreateManyAndReturnCycle!]!
  createManyAndReturnIssue(data: [IssueCreateManyInput!]!): [CreateManyAndReturnIssue!]!
  createManyAndReturnIssueLabel(data: [IssueLabelCreateManyInput!]!): [CreateManyAndReturnIssueLabel!]!
  createManyAndReturnIssuePriority(data: [IssuePriorityCreateManyInput!]!): [CreateManyAndReturnIssuePriority!]!
  createManyAndReturnIssueStatus(data: [IssueStatusCreateManyInput!]!): [CreateManyAndReturnIssueStatus!]!
  createManyAndReturnLabel(data: [LabelCreateManyInput!]!): [CreateManyAndReturnLabel!]!
  createManyAndReturnProject(data: [ProjectCreateManyInput!]!): [CreateManyAndReturnProject!]!
  createManyAndReturnSubtask(data: [SubtaskCreateManyInput!]!): [CreateManyAndReturnSubtask!]!
  createManyAndReturnSyncConflict(data: [SyncConflictCreateManyInput!]!): [CreateManyAndReturnSyncConflict!]!
  createManyAndReturnSyncOperation(data: [SyncOperationCreateManyInput!]!): [CreateManyAndReturnSyncOperation!]!
  createManyAndReturnTask(data: [TaskCreateManyInput!]!): [CreateManyAndReturnTask!]!
  createManyAndReturnTaskDependency(data: [TaskDependencyCreateManyInput!]!): [CreateManyAndReturnTaskDependency!]!
  createManyAndReturnTaskMasterMetadata(data: [TaskMasterMetadataCreateManyInput!]!): [CreateManyAndReturnTaskMasterMetadata!]!
  createManyAndReturnTeam(data: [TeamCreateManyInput!]!): [CreateManyAndReturnTeam!]!
  createManyAndReturnTeamMember(data: [TeamMemberCreateManyInput!]!): [CreateManyAndReturnTeamMember!]!
  createManyAndReturnTeamProject(data: [TeamProjectCreateManyInput!]!): [CreateManyAndReturnTeamProject!]!
  createManyAndReturnUser(data: [UserCreateManyInput!]!): [CreateManyAndReturnUser!]!
  createManyCycle(data: [CycleCreateManyInput!]!): AffectedRowsOutput!
  createManyIssue(data: [IssueCreateManyInput!]!): AffectedRowsOutput!
  createManyIssueLabel(data: [IssueLabelCreateManyInput!]!): AffectedRowsOutput!
  createManyIssuePriority(data: [IssuePriorityCreateManyInput!]!): AffectedRowsOutput!
  createManyIssueStatus(data: [IssueStatusCreateManyInput!]!): AffectedRowsOutput!
  createManyLabel(data: [LabelCreateManyInput!]!): AffectedRowsOutput!
  createManyProject(data: [ProjectCreateManyInput!]!): AffectedRowsOutput!
  createManySubtask(data: [SubtaskCreateManyInput!]!): AffectedRowsOutput!
  createManySyncConflict(data: [SyncConflictCreateManyInput!]!): AffectedRowsOutput!
  createManySyncOperation(data: [SyncOperationCreateManyInput!]!): AffectedRowsOutput!
  createManyTask(data: [TaskCreateManyInput!]!): AffectedRowsOutput!
  createManyTaskDependency(data: [TaskDependencyCreateManyInput!]!): AffectedRowsOutput!
  createManyTaskMasterMetadata(data: [TaskMasterMetadataCreateManyInput!]!): AffectedRowsOutput!
  createManyTeam(data: [TeamCreateManyInput!]!): AffectedRowsOutput!
  createManyTeamMember(data: [TeamMemberCreateManyInput!]!): AffectedRowsOutput!
  createManyTeamProject(data: [TeamProjectCreateManyInput!]!): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!): AffectedRowsOutput!
  createOneCycle(data: CycleCreateInput!): Cycle!
  createOneIssue(data: IssueCreateInput!): Issue!
  createOneIssueLabel(data: IssueLabelCreateInput!): IssueLabel!
  createOneIssuePriority(data: IssuePriorityCreateInput!): IssuePriority!
  createOneIssueStatus(data: IssueStatusCreateInput!): IssueStatus!
  createOneLabel(data: LabelCreateInput!): Label!
  createOneProject(data: ProjectCreateInput!): Project!
  createOneSubtask(data: SubtaskCreateInput!): Subtask!
  createOneSyncConflict(data: SyncConflictCreateInput!): SyncConflict!
  createOneSyncOperation(data: SyncOperationCreateInput!): SyncOperation!
  createOneTask(data: TaskCreateInput!): Task!
  createOneTaskDependency(data: TaskDependencyCreateInput!): TaskDependency!
  createOneTaskMasterMetadata(data: TaskMasterMetadataCreateInput!): TaskMasterMetadata!
  createOneTeam(data: TeamCreateInput!): Team!
  createOneTeamMember(data: TeamMemberCreateInput!): TeamMember!
  createOneTeamProject(data: TeamProjectCreateInput!): TeamProject!
  createOneUser(data: UserCreateInput!): User!
  deleteManyCycle(where: CycleWhereInput): AffectedRowsOutput!
  deleteManyIssue(where: IssueWhereInput): AffectedRowsOutput!
  deleteManyIssueLabel(where: IssueLabelWhereInput): AffectedRowsOutput!
  deleteManyIssuePriority(where: IssuePriorityWhereInput): AffectedRowsOutput!
  deleteManyIssueStatus(where: IssueStatusWhereInput): AffectedRowsOutput!
  deleteManyLabel(where: LabelWhereInput): AffectedRowsOutput!
  deleteManyProject(where: ProjectWhereInput): AffectedRowsOutput!
  deleteManySubtask(where: SubtaskWhereInput): AffectedRowsOutput!
  deleteManySyncConflict(where: SyncConflictWhereInput): AffectedRowsOutput!
  deleteManySyncOperation(where: SyncOperationWhereInput): AffectedRowsOutput!
  deleteManyTask(where: TaskWhereInput): AffectedRowsOutput!
  deleteManyTaskDependency(where: TaskDependencyWhereInput): AffectedRowsOutput!
  deleteManyTaskMasterMetadata(where: TaskMasterMetadataWhereInput): AffectedRowsOutput!
  deleteManyTeam(where: TeamWhereInput): AffectedRowsOutput!
  deleteManyTeamMember(where: TeamMemberWhereInput): AffectedRowsOutput!
  deleteManyTeamProject(where: TeamProjectWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteOneCycle(where: CycleWhereUniqueInput!): Cycle
  deleteOneIssue(where: IssueWhereUniqueInput!): Issue
  deleteOneIssueLabel(where: IssueLabelWhereUniqueInput!): IssueLabel
  deleteOneIssuePriority(where: IssuePriorityWhereUniqueInput!): IssuePriority
  deleteOneIssueStatus(where: IssueStatusWhereUniqueInput!): IssueStatus
  deleteOneLabel(where: LabelWhereUniqueInput!): Label
  deleteOneProject(where: ProjectWhereUniqueInput!): Project
  deleteOneSubtask(where: SubtaskWhereUniqueInput!): Subtask
  deleteOneSyncConflict(where: SyncConflictWhereUniqueInput!): SyncConflict
  deleteOneSyncOperation(where: SyncOperationWhereUniqueInput!): SyncOperation
  deleteOneTask(where: TaskWhereUniqueInput!): Task
  deleteOneTaskDependency(where: TaskDependencyWhereUniqueInput!): TaskDependency
  deleteOneTaskMasterMetadata(where: TaskMasterMetadataWhereUniqueInput!): TaskMasterMetadata
  deleteOneTeam(where: TeamWhereUniqueInput!): Team
  deleteOneTeamMember(where: TeamMemberWhereUniqueInput!): TeamMember
  deleteOneTeamProject(where: TeamProjectWhereUniqueInput!): TeamProject
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyCycle(data: CycleUpdateManyMutationInput!, where: CycleWhereInput): AffectedRowsOutput!
  updateManyIssue(data: IssueUpdateManyMutationInput!, where: IssueWhereInput): AffectedRowsOutput!
  updateManyIssueLabel(data: IssueLabelUpdateManyMutationInput!, where: IssueLabelWhereInput): AffectedRowsOutput!
  updateManyIssuePriority(data: IssuePriorityUpdateManyMutationInput!, where: IssuePriorityWhereInput): AffectedRowsOutput!
  updateManyIssueStatus(data: IssueStatusUpdateManyMutationInput!, where: IssueStatusWhereInput): AffectedRowsOutput!
  updateManyLabel(data: LabelUpdateManyMutationInput!, where: LabelWhereInput): AffectedRowsOutput!
  updateManyProject(data: ProjectUpdateManyMutationInput!, where: ProjectWhereInput): AffectedRowsOutput!
  updateManySubtask(data: SubtaskUpdateManyMutationInput!, where: SubtaskWhereInput): AffectedRowsOutput!
  updateManySyncConflict(data: SyncConflictUpdateManyMutationInput!, where: SyncConflictWhereInput): AffectedRowsOutput!
  updateManySyncOperation(data: SyncOperationUpdateManyMutationInput!, where: SyncOperationWhereInput): AffectedRowsOutput!
  updateManyTask(data: TaskUpdateManyMutationInput!, where: TaskWhereInput): AffectedRowsOutput!
  updateManyTaskDependency(data: TaskDependencyUpdateManyMutationInput!, where: TaskDependencyWhereInput): AffectedRowsOutput!
  updateManyTaskMasterMetadata(data: TaskMasterMetadataUpdateManyMutationInput!, where: TaskMasterMetadataWhereInput): AffectedRowsOutput!
  updateManyTeam(data: TeamUpdateManyMutationInput!, where: TeamWhereInput): AffectedRowsOutput!
  updateManyTeamMember(data: TeamMemberUpdateManyMutationInput!, where: TeamMemberWhereInput): AffectedRowsOutput!
  updateManyTeamProject(data: TeamProjectUpdateManyMutationInput!, where: TeamProjectWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateOneCycle(data: CycleUpdateInput!, where: CycleWhereUniqueInput!): Cycle
  updateOneIssue(data: IssueUpdateInput!, where: IssueWhereUniqueInput!): Issue
  updateOneIssueLabel(data: IssueLabelUpdateInput!, where: IssueLabelWhereUniqueInput!): IssueLabel
  updateOneIssuePriority(data: IssuePriorityUpdateInput!, where: IssuePriorityWhereUniqueInput!): IssuePriority
  updateOneIssueStatus(data: IssueStatusUpdateInput!, where: IssueStatusWhereUniqueInput!): IssueStatus
  updateOneLabel(data: LabelUpdateInput!, where: LabelWhereUniqueInput!): Label
  updateOneProject(data: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project
  updateOneSubtask(data: SubtaskUpdateInput!, where: SubtaskWhereUniqueInput!): Subtask
  updateOneSyncConflict(data: SyncConflictUpdateInput!, where: SyncConflictWhereUniqueInput!): SyncConflict
  updateOneSyncOperation(data: SyncOperationUpdateInput!, where: SyncOperationWhereUniqueInput!): SyncOperation
  updateOneTask(data: TaskUpdateInput!, where: TaskWhereUniqueInput!): Task
  updateOneTaskDependency(data: TaskDependencyUpdateInput!, where: TaskDependencyWhereUniqueInput!): TaskDependency
  updateOneTaskMasterMetadata(data: TaskMasterMetadataUpdateInput!, where: TaskMasterMetadataWhereUniqueInput!): TaskMasterMetadata
  updateOneTeam(data: TeamUpdateInput!, where: TeamWhereUniqueInput!): Team
  updateOneTeamMember(data: TeamMemberUpdateInput!, where: TeamMemberWhereUniqueInput!): TeamMember
  updateOneTeamProject(data: TeamProjectUpdateInput!, where: TeamProjectWhereUniqueInput!): TeamProject
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertOneCycle(create: CycleCreateInput!, update: CycleUpdateInput!, where: CycleWhereUniqueInput!): Cycle!
  upsertOneIssue(create: IssueCreateInput!, update: IssueUpdateInput!, where: IssueWhereUniqueInput!): Issue!
  upsertOneIssueLabel(create: IssueLabelCreateInput!, update: IssueLabelUpdateInput!, where: IssueLabelWhereUniqueInput!): IssueLabel!
  upsertOneIssuePriority(create: IssuePriorityCreateInput!, update: IssuePriorityUpdateInput!, where: IssuePriorityWhereUniqueInput!): IssuePriority!
  upsertOneIssueStatus(create: IssueStatusCreateInput!, update: IssueStatusUpdateInput!, where: IssueStatusWhereUniqueInput!): IssueStatus!
  upsertOneLabel(create: LabelCreateInput!, update: LabelUpdateInput!, where: LabelWhereUniqueInput!): Label!
  upsertOneProject(create: ProjectCreateInput!, update: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project!
  upsertOneSubtask(create: SubtaskCreateInput!, update: SubtaskUpdateInput!, where: SubtaskWhereUniqueInput!): Subtask!
  upsertOneSyncConflict(create: SyncConflictCreateInput!, update: SyncConflictUpdateInput!, where: SyncConflictWhereUniqueInput!): SyncConflict!
  upsertOneSyncOperation(create: SyncOperationCreateInput!, update: SyncOperationUpdateInput!, where: SyncOperationWhereUniqueInput!): SyncOperation!
  upsertOneTask(create: TaskCreateInput!, update: TaskUpdateInput!, where: TaskWhereUniqueInput!): Task!
  upsertOneTaskDependency(create: TaskDependencyCreateInput!, update: TaskDependencyUpdateInput!, where: TaskDependencyWhereUniqueInput!): TaskDependency!
  upsertOneTaskMasterMetadata(create: TaskMasterMetadataCreateInput!, update: TaskMasterMetadataUpdateInput!, where: TaskMasterMetadataWhereUniqueInput!): TaskMasterMetadata!
  upsertOneTeam(create: TeamCreateInput!, update: TeamUpdateInput!, where: TeamWhereUniqueInput!): Team!
  upsertOneTeamMember(create: TeamMemberCreateInput!, update: TeamMemberUpdateInput!, where: TeamMemberWhereUniqueInput!): TeamMember!
  upsertOneTeamProject(create: TeamProjectCreateInput!, update: TeamProjectUpdateInput!, where: TeamProjectWhereUniqueInput!): TeamProject!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableIntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

enum NullsOrder {
  first
  last
}

type Project {
  _count: ProjectCount
  color: String
  createdAt: DateTime!
  description: String
  health: String!
  icon: String
  id: String!
  identifier: String
  leadId: String
  name: String!
  percentComplete: Int!
  startDate: DateTime
  updatedAt: DateTime!
}

type ProjectAvgAggregate {
  percentComplete: Float
}

input ProjectAvgOrderByAggregateInput {
  percentComplete: SortOrder
}

type ProjectCount {
  issues(where: IssueWhereInput): Int!
  teams(where: TeamProjectWhereInput): Int!
}

type ProjectCountAggregate {
  _all: Int!
  color: Int!
  createdAt: Int!
  description: Int!
  health: Int!
  icon: Int!
  id: Int!
  identifier: Int!
  leadId: Int!
  name: Int!
  percentComplete: Int!
  startDate: Int!
  updatedAt: Int!
}

input ProjectCountOrderByAggregateInput {
  color: SortOrder
  createdAt: SortOrder
  description: SortOrder
  health: SortOrder
  icon: SortOrder
  id: SortOrder
  identifier: SortOrder
  leadId: SortOrder
  name: SortOrder
  percentComplete: SortOrder
  startDate: SortOrder
  updatedAt: SortOrder
}

input ProjectCreateInput {
  color: String
  createdAt: DateTime
  description: String
  health: String
  icon: String
  id: String
  identifier: String
  issues: IssueCreateNestedManyWithoutProjectInput
  lead: UserCreateNestedOneWithoutLedProjectsInput
  name: String!
  percentComplete: Int
  startDate: DateTime
  teams: TeamProjectCreateNestedManyWithoutProjectInput
  updatedAt: DateTime
}

input ProjectCreateManyInput {
  color: String
  createdAt: DateTime
  description: String
  health: String
  icon: String
  id: String
  identifier: String
  leadId: String
  name: String!
  percentComplete: Int
  startDate: DateTime
  updatedAt: DateTime
}

input ProjectCreateManyLeadInput {
  color: String
  createdAt: DateTime
  description: String
  health: String
  icon: String
  id: String
  identifier: String
  name: String!
  percentComplete: Int
  startDate: DateTime
  updatedAt: DateTime
}

input ProjectCreateManyLeadInputEnvelope {
  data: [ProjectCreateManyLeadInput!]!
}

input ProjectCreateNestedManyWithoutLeadInput {
  connect: [ProjectWhereUniqueInput!]
  connectOrCreate: [ProjectCreateOrConnectWithoutLeadInput!]
  create: [ProjectCreateWithoutLeadInput!]
  createMany: ProjectCreateManyLeadInputEnvelope
}

input ProjectCreateNestedOneWithoutIssuesInput {
  connect: ProjectWhereUniqueInput
  connectOrCreate: ProjectCreateOrConnectWithoutIssuesInput
  create: ProjectCreateWithoutIssuesInput
}

input ProjectCreateNestedOneWithoutTeamsInput {
  connect: ProjectWhereUniqueInput
  connectOrCreate: ProjectCreateOrConnectWithoutTeamsInput
  create: ProjectCreateWithoutTeamsInput
}

input ProjectCreateOrConnectWithoutIssuesInput {
  create: ProjectCreateWithoutIssuesInput!
  where: ProjectWhereUniqueInput!
}

input ProjectCreateOrConnectWithoutLeadInput {
  create: ProjectCreateWithoutLeadInput!
  where: ProjectWhereUniqueInput!
}

input ProjectCreateOrConnectWithoutTeamsInput {
  create: ProjectCreateWithoutTeamsInput!
  where: ProjectWhereUniqueInput!
}

input ProjectCreateWithoutIssuesInput {
  color: String
  createdAt: DateTime
  description: String
  health: String
  icon: String
  id: String
  identifier: String
  lead: UserCreateNestedOneWithoutLedProjectsInput
  name: String!
  percentComplete: Int
  startDate: DateTime
  teams: TeamProjectCreateNestedManyWithoutProjectInput
  updatedAt: DateTime
}

input ProjectCreateWithoutLeadInput {
  color: String
  createdAt: DateTime
  description: String
  health: String
  icon: String
  id: String
  identifier: String
  issues: IssueCreateNestedManyWithoutProjectInput
  name: String!
  percentComplete: Int
  startDate: DateTime
  teams: TeamProjectCreateNestedManyWithoutProjectInput
  updatedAt: DateTime
}

input ProjectCreateWithoutTeamsInput {
  color: String
  createdAt: DateTime
  description: String
  health: String
  icon: String
  id: String
  identifier: String
  issues: IssueCreateNestedManyWithoutProjectInput
  lead: UserCreateNestedOneWithoutLedProjectsInput
  name: String!
  percentComplete: Int
  startDate: DateTime
  updatedAt: DateTime
}

type ProjectGroupBy {
  _avg: ProjectAvgAggregate
  _count: ProjectCountAggregate
  _max: ProjectMaxAggregate
  _min: ProjectMinAggregate
  _sum: ProjectSumAggregate
  color: String
  createdAt: DateTime!
  description: String
  health: String!
  icon: String
  id: String!
  identifier: String
  leadId: String
  name: String!
  percentComplete: Int!
  startDate: DateTime
  updatedAt: DateTime!
}

input ProjectListRelationFilter {
  every: ProjectWhereInput
  none: ProjectWhereInput
  some: ProjectWhereInput
}

type ProjectMaxAggregate {
  color: String
  createdAt: DateTime
  description: String
  health: String
  icon: String
  id: String
  identifier: String
  leadId: String
  name: String
  percentComplete: Int
  startDate: DateTime
  updatedAt: DateTime
}

input ProjectMaxOrderByAggregateInput {
  color: SortOrder
  createdAt: SortOrder
  description: SortOrder
  health: SortOrder
  icon: SortOrder
  id: SortOrder
  identifier: SortOrder
  leadId: SortOrder
  name: SortOrder
  percentComplete: SortOrder
  startDate: SortOrder
  updatedAt: SortOrder
}

type ProjectMinAggregate {
  color: String
  createdAt: DateTime
  description: String
  health: String
  icon: String
  id: String
  identifier: String
  leadId: String
  name: String
  percentComplete: Int
  startDate: DateTime
  updatedAt: DateTime
}

input ProjectMinOrderByAggregateInput {
  color: SortOrder
  createdAt: SortOrder
  description: SortOrder
  health: SortOrder
  icon: SortOrder
  id: SortOrder
  identifier: SortOrder
  leadId: SortOrder
  name: SortOrder
  percentComplete: SortOrder
  startDate: SortOrder
  updatedAt: SortOrder
}

input ProjectNullableRelationFilter {
  is: ProjectWhereInput
  isNot: ProjectWhereInput
}

input ProjectOrderByRelationAggregateInput {
  _count: SortOrder
}

input ProjectOrderByWithAggregationInput {
  _avg: ProjectAvgOrderByAggregateInput
  _count: ProjectCountOrderByAggregateInput
  _max: ProjectMaxOrderByAggregateInput
  _min: ProjectMinOrderByAggregateInput
  _sum: ProjectSumOrderByAggregateInput
  color: SortOrderInput
  createdAt: SortOrder
  description: SortOrderInput
  health: SortOrder
  icon: SortOrderInput
  id: SortOrder
  identifier: SortOrderInput
  leadId: SortOrderInput
  name: SortOrder
  percentComplete: SortOrder
  startDate: SortOrderInput
  updatedAt: SortOrder
}

input ProjectOrderByWithRelationInput {
  color: SortOrderInput
  createdAt: SortOrder
  description: SortOrderInput
  health: SortOrder
  icon: SortOrderInput
  id: SortOrder
  identifier: SortOrderInput
  issues: IssueOrderByRelationAggregateInput
  lead: UserOrderByWithRelationInput
  leadId: SortOrderInput
  name: SortOrder
  percentComplete: SortOrder
  startDate: SortOrderInput
  teams: TeamProjectOrderByRelationAggregateInput
  updatedAt: SortOrder
}

input ProjectRelationFilter {
  is: ProjectWhereInput
  isNot: ProjectWhereInput
}

enum ProjectScalarFieldEnum {
  color
  createdAt
  description
  health
  icon
  id
  identifier
  leadId
  name
  percentComplete
  startDate
  updatedAt
}

input ProjectScalarWhereInput {
  AND: [ProjectScalarWhereInput!]
  NOT: [ProjectScalarWhereInput!]
  OR: [ProjectScalarWhereInput!]
  color: StringNullableFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  health: StringFilter
  icon: StringNullableFilter
  id: StringFilter
  identifier: StringNullableFilter
  leadId: StringNullableFilter
  name: StringFilter
  percentComplete: IntFilter
  startDate: DateTimeNullableFilter
  updatedAt: DateTimeFilter
}

input ProjectScalarWhereWithAggregatesInput {
  AND: [ProjectScalarWhereWithAggregatesInput!]
  NOT: [ProjectScalarWhereWithAggregatesInput!]
  OR: [ProjectScalarWhereWithAggregatesInput!]
  color: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  description: StringNullableWithAggregatesFilter
  health: StringWithAggregatesFilter
  icon: StringNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  identifier: StringNullableWithAggregatesFilter
  leadId: StringNullableWithAggregatesFilter
  name: StringWithAggregatesFilter
  percentComplete: IntWithAggregatesFilter
  startDate: DateTimeNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type ProjectSumAggregate {
  percentComplete: Int
}

input ProjectSumOrderByAggregateInput {
  percentComplete: SortOrder
}

input ProjectUpdateInput {
  color: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  health: StringFieldUpdateOperationsInput
  icon: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  identifier: NullableStringFieldUpdateOperationsInput
  issues: IssueUpdateManyWithoutProjectNestedInput
  lead: UserUpdateOneWithoutLedProjectsNestedInput
  name: StringFieldUpdateOperationsInput
  percentComplete: IntFieldUpdateOperationsInput
  startDate: NullableDateTimeFieldUpdateOperationsInput
  teams: TeamProjectUpdateManyWithoutProjectNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateManyMutationInput {
  color: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  health: StringFieldUpdateOperationsInput
  icon: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  identifier: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  percentComplete: IntFieldUpdateOperationsInput
  startDate: NullableDateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateManyWithWhereWithoutLeadInput {
  data: ProjectUpdateManyMutationInput!
  where: ProjectScalarWhereInput!
}

input ProjectUpdateManyWithoutLeadNestedInput {
  connect: [ProjectWhereUniqueInput!]
  connectOrCreate: [ProjectCreateOrConnectWithoutLeadInput!]
  create: [ProjectCreateWithoutLeadInput!]
  createMany: ProjectCreateManyLeadInputEnvelope
  delete: [ProjectWhereUniqueInput!]
  deleteMany: [ProjectScalarWhereInput!]
  disconnect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  update: [ProjectUpdateWithWhereUniqueWithoutLeadInput!]
  updateMany: [ProjectUpdateManyWithWhereWithoutLeadInput!]
  upsert: [ProjectUpsertWithWhereUniqueWithoutLeadInput!]
}

input ProjectUpdateOneRequiredWithoutTeamsNestedInput {
  connect: ProjectWhereUniqueInput
  connectOrCreate: ProjectCreateOrConnectWithoutTeamsInput
  create: ProjectCreateWithoutTeamsInput
  update: ProjectUpdateToOneWithWhereWithoutTeamsInput
  upsert: ProjectUpsertWithoutTeamsInput
}

input ProjectUpdateOneWithoutIssuesNestedInput {
  connect: ProjectWhereUniqueInput
  connectOrCreate: ProjectCreateOrConnectWithoutIssuesInput
  create: ProjectCreateWithoutIssuesInput
  delete: ProjectWhereInput
  disconnect: ProjectWhereInput
  update: ProjectUpdateToOneWithWhereWithoutIssuesInput
  upsert: ProjectUpsertWithoutIssuesInput
}

input ProjectUpdateToOneWithWhereWithoutIssuesInput {
  data: ProjectUpdateWithoutIssuesInput!
  where: ProjectWhereInput
}

input ProjectUpdateToOneWithWhereWithoutTeamsInput {
  data: ProjectUpdateWithoutTeamsInput!
  where: ProjectWhereInput
}

input ProjectUpdateWithWhereUniqueWithoutLeadInput {
  data: ProjectUpdateWithoutLeadInput!
  where: ProjectWhereUniqueInput!
}

input ProjectUpdateWithoutIssuesInput {
  color: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  health: StringFieldUpdateOperationsInput
  icon: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  identifier: NullableStringFieldUpdateOperationsInput
  lead: UserUpdateOneWithoutLedProjectsNestedInput
  name: StringFieldUpdateOperationsInput
  percentComplete: IntFieldUpdateOperationsInput
  startDate: NullableDateTimeFieldUpdateOperationsInput
  teams: TeamProjectUpdateManyWithoutProjectNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateWithoutLeadInput {
  color: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  health: StringFieldUpdateOperationsInput
  icon: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  identifier: NullableStringFieldUpdateOperationsInput
  issues: IssueUpdateManyWithoutProjectNestedInput
  name: StringFieldUpdateOperationsInput
  percentComplete: IntFieldUpdateOperationsInput
  startDate: NullableDateTimeFieldUpdateOperationsInput
  teams: TeamProjectUpdateManyWithoutProjectNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateWithoutTeamsInput {
  color: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  health: StringFieldUpdateOperationsInput
  icon: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  identifier: NullableStringFieldUpdateOperationsInput
  issues: IssueUpdateManyWithoutProjectNestedInput
  lead: UserUpdateOneWithoutLedProjectsNestedInput
  name: StringFieldUpdateOperationsInput
  percentComplete: IntFieldUpdateOperationsInput
  startDate: NullableDateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpsertWithWhereUniqueWithoutLeadInput {
  create: ProjectCreateWithoutLeadInput!
  update: ProjectUpdateWithoutLeadInput!
  where: ProjectWhereUniqueInput!
}

input ProjectUpsertWithoutIssuesInput {
  create: ProjectCreateWithoutIssuesInput!
  update: ProjectUpdateWithoutIssuesInput!
  where: ProjectWhereInput
}

input ProjectUpsertWithoutTeamsInput {
  create: ProjectCreateWithoutTeamsInput!
  update: ProjectUpdateWithoutTeamsInput!
  where: ProjectWhereInput
}

input ProjectWhereInput {
  AND: [ProjectWhereInput!]
  NOT: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  color: StringNullableFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  health: StringFilter
  icon: StringNullableFilter
  id: StringFilter
  identifier: StringNullableFilter
  issues: IssueListRelationFilter
  lead: UserNullableRelationFilter
  leadId: StringNullableFilter
  name: StringFilter
  percentComplete: IntFilter
  startDate: DateTimeNullableFilter
  teams: TeamProjectListRelationFilter
  updatedAt: DateTimeFilter
}

input ProjectWhereUniqueInput {
  AND: [ProjectWhereInput!]
  NOT: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  color: StringNullableFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  health: StringFilter
  icon: StringNullableFilter
  id: String
  identifier: StringNullableFilter
  issues: IssueListRelationFilter
  lead: UserNullableRelationFilter
  leadId: StringNullableFilter
  name: StringFilter
  percentComplete: IntFilter
  startDate: DateTimeNullableFilter
  teams: TeamProjectListRelationFilter
  updatedAt: DateTimeFilter
}

type Query {
  aggregateCycle(cursor: CycleWhereUniqueInput, orderBy: [CycleOrderByWithRelationInput!], skip: Int, take: Int, where: CycleWhereInput): AggregateCycle!
  aggregateIssue(cursor: IssueWhereUniqueInput, orderBy: [IssueOrderByWithRelationInput!], skip: Int, take: Int, where: IssueWhereInput): AggregateIssue!
  aggregateIssueLabel(cursor: IssueLabelWhereUniqueInput, orderBy: [IssueLabelOrderByWithRelationInput!], skip: Int, take: Int, where: IssueLabelWhereInput): AggregateIssueLabel!
  aggregateIssuePriority(cursor: IssuePriorityWhereUniqueInput, orderBy: [IssuePriorityOrderByWithRelationInput!], skip: Int, take: Int, where: IssuePriorityWhereInput): AggregateIssuePriority!
  aggregateIssueStatus(cursor: IssueStatusWhereUniqueInput, orderBy: [IssueStatusOrderByWithRelationInput!], skip: Int, take: Int, where: IssueStatusWhereInput): AggregateIssueStatus!
  aggregateLabel(cursor: LabelWhereUniqueInput, orderBy: [LabelOrderByWithRelationInput!], skip: Int, take: Int, where: LabelWhereInput): AggregateLabel!
  aggregateProject(cursor: ProjectWhereUniqueInput, orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): AggregateProject!
  aggregateSubtask(cursor: SubtaskWhereUniqueInput, orderBy: [SubtaskOrderByWithRelationInput!], skip: Int, take: Int, where: SubtaskWhereInput): AggregateSubtask!
  aggregateSyncConflict(cursor: SyncConflictWhereUniqueInput, orderBy: [SyncConflictOrderByWithRelationInput!], skip: Int, take: Int, where: SyncConflictWhereInput): AggregateSyncConflict!
  aggregateSyncOperation(cursor: SyncOperationWhereUniqueInput, orderBy: [SyncOperationOrderByWithRelationInput!], skip: Int, take: Int, where: SyncOperationWhereInput): AggregateSyncOperation!
  aggregateTask(cursor: TaskWhereUniqueInput, orderBy: [TaskOrderByWithRelationInput!], skip: Int, take: Int, where: TaskWhereInput): AggregateTask!
  aggregateTaskDependency(cursor: TaskDependencyWhereUniqueInput, orderBy: [TaskDependencyOrderByWithRelationInput!], skip: Int, take: Int, where: TaskDependencyWhereInput): AggregateTaskDependency!
  aggregateTaskMasterMetadata(cursor: TaskMasterMetadataWhereUniqueInput, orderBy: [TaskMasterMetadataOrderByWithRelationInput!], skip: Int, take: Int, where: TaskMasterMetadataWhereInput): AggregateTaskMasterMetadata!
  aggregateTeam(cursor: TeamWhereUniqueInput, orderBy: [TeamOrderByWithRelationInput!], skip: Int, take: Int, where: TeamWhereInput): AggregateTeam!
  aggregateTeamMember(cursor: TeamMemberWhereUniqueInput, orderBy: [TeamMemberOrderByWithRelationInput!], skip: Int, take: Int, where: TeamMemberWhereInput): AggregateTeamMember!
  aggregateTeamProject(cursor: TeamProjectWhereUniqueInput, orderBy: [TeamProjectOrderByWithRelationInput!], skip: Int, take: Int, where: TeamProjectWhereInput): AggregateTeamProject!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  availableCommands: [CLICommand!]!
  cliCommand(name: String!): CLICommand
  cliHistory(filter: CLIHistoryFilter, limit: Float = 50): [CLIHistoryItem!]!
  cliStatus: CLIStatus!
  cycle(where: CycleWhereUniqueInput!): Cycle
  cycles(cursor: CycleWhereUniqueInput, distinct: [CycleScalarFieldEnum!], orderBy: [CycleOrderByWithRelationInput!], skip: Int, take: Int, where: CycleWhereInput): [Cycle!]!
  findFirstCycle(cursor: CycleWhereUniqueInput, distinct: [CycleScalarFieldEnum!], orderBy: [CycleOrderByWithRelationInput!], skip: Int, take: Int, where: CycleWhereInput): Cycle
  findFirstCycleOrThrow(cursor: CycleWhereUniqueInput, distinct: [CycleScalarFieldEnum!], orderBy: [CycleOrderByWithRelationInput!], skip: Int, take: Int, where: CycleWhereInput): Cycle
  findFirstIssue(cursor: IssueWhereUniqueInput, distinct: [IssueScalarFieldEnum!], orderBy: [IssueOrderByWithRelationInput!], skip: Int, take: Int, where: IssueWhereInput): Issue
  findFirstIssueLabel(cursor: IssueLabelWhereUniqueInput, distinct: [IssueLabelScalarFieldEnum!], orderBy: [IssueLabelOrderByWithRelationInput!], skip: Int, take: Int, where: IssueLabelWhereInput): IssueLabel
  findFirstIssueLabelOrThrow(cursor: IssueLabelWhereUniqueInput, distinct: [IssueLabelScalarFieldEnum!], orderBy: [IssueLabelOrderByWithRelationInput!], skip: Int, take: Int, where: IssueLabelWhereInput): IssueLabel
  findFirstIssueOrThrow(cursor: IssueWhereUniqueInput, distinct: [IssueScalarFieldEnum!], orderBy: [IssueOrderByWithRelationInput!], skip: Int, take: Int, where: IssueWhereInput): Issue
  findFirstIssuePriority(cursor: IssuePriorityWhereUniqueInput, distinct: [IssuePriorityScalarFieldEnum!], orderBy: [IssuePriorityOrderByWithRelationInput!], skip: Int, take: Int, where: IssuePriorityWhereInput): IssuePriority
  findFirstIssuePriorityOrThrow(cursor: IssuePriorityWhereUniqueInput, distinct: [IssuePriorityScalarFieldEnum!], orderBy: [IssuePriorityOrderByWithRelationInput!], skip: Int, take: Int, where: IssuePriorityWhereInput): IssuePriority
  findFirstIssueStatus(cursor: IssueStatusWhereUniqueInput, distinct: [IssueStatusScalarFieldEnum!], orderBy: [IssueStatusOrderByWithRelationInput!], skip: Int, take: Int, where: IssueStatusWhereInput): IssueStatus
  findFirstIssueStatusOrThrow(cursor: IssueStatusWhereUniqueInput, distinct: [IssueStatusScalarFieldEnum!], orderBy: [IssueStatusOrderByWithRelationInput!], skip: Int, take: Int, where: IssueStatusWhereInput): IssueStatus
  findFirstLabel(cursor: LabelWhereUniqueInput, distinct: [LabelScalarFieldEnum!], orderBy: [LabelOrderByWithRelationInput!], skip: Int, take: Int, where: LabelWhereInput): Label
  findFirstLabelOrThrow(cursor: LabelWhereUniqueInput, distinct: [LabelScalarFieldEnum!], orderBy: [LabelOrderByWithRelationInput!], skip: Int, take: Int, where: LabelWhereInput): Label
  findFirstProject(cursor: ProjectWhereUniqueInput, distinct: [ProjectScalarFieldEnum!], orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): Project
  findFirstProjectOrThrow(cursor: ProjectWhereUniqueInput, distinct: [ProjectScalarFieldEnum!], orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): Project
  findFirstSubtask(cursor: SubtaskWhereUniqueInput, distinct: [SubtaskScalarFieldEnum!], orderBy: [SubtaskOrderByWithRelationInput!], skip: Int, take: Int, where: SubtaskWhereInput): Subtask
  findFirstSubtaskOrThrow(cursor: SubtaskWhereUniqueInput, distinct: [SubtaskScalarFieldEnum!], orderBy: [SubtaskOrderByWithRelationInput!], skip: Int, take: Int, where: SubtaskWhereInput): Subtask
  findFirstSyncConflict(cursor: SyncConflictWhereUniqueInput, distinct: [SyncConflictScalarFieldEnum!], orderBy: [SyncConflictOrderByWithRelationInput!], skip: Int, take: Int, where: SyncConflictWhereInput): SyncConflict
  findFirstSyncConflictOrThrow(cursor: SyncConflictWhereUniqueInput, distinct: [SyncConflictScalarFieldEnum!], orderBy: [SyncConflictOrderByWithRelationInput!], skip: Int, take: Int, where: SyncConflictWhereInput): SyncConflict
  findFirstSyncOperation(cursor: SyncOperationWhereUniqueInput, distinct: [SyncOperationScalarFieldEnum!], orderBy: [SyncOperationOrderByWithRelationInput!], skip: Int, take: Int, where: SyncOperationWhereInput): SyncOperation
  findFirstSyncOperationOrThrow(cursor: SyncOperationWhereUniqueInput, distinct: [SyncOperationScalarFieldEnum!], orderBy: [SyncOperationOrderByWithRelationInput!], skip: Int, take: Int, where: SyncOperationWhereInput): SyncOperation
  findFirstTask(cursor: TaskWhereUniqueInput, distinct: [TaskScalarFieldEnum!], orderBy: [TaskOrderByWithRelationInput!], skip: Int, take: Int, where: TaskWhereInput): Task
  findFirstTaskDependency(cursor: TaskDependencyWhereUniqueInput, distinct: [TaskDependencyScalarFieldEnum!], orderBy: [TaskDependencyOrderByWithRelationInput!], skip: Int, take: Int, where: TaskDependencyWhereInput): TaskDependency
  findFirstTaskDependencyOrThrow(cursor: TaskDependencyWhereUniqueInput, distinct: [TaskDependencyScalarFieldEnum!], orderBy: [TaskDependencyOrderByWithRelationInput!], skip: Int, take: Int, where: TaskDependencyWhereInput): TaskDependency
  findFirstTaskMasterMetadata(cursor: TaskMasterMetadataWhereUniqueInput, distinct: [TaskMasterMetadataScalarFieldEnum!], orderBy: [TaskMasterMetadataOrderByWithRelationInput!], skip: Int, take: Int, where: TaskMasterMetadataWhereInput): TaskMasterMetadata
  findFirstTaskMasterMetadataOrThrow(cursor: TaskMasterMetadataWhereUniqueInput, distinct: [TaskMasterMetadataScalarFieldEnum!], orderBy: [TaskMasterMetadataOrderByWithRelationInput!], skip: Int, take: Int, where: TaskMasterMetadataWhereInput): TaskMasterMetadata
  findFirstTaskOrThrow(cursor: TaskWhereUniqueInput, distinct: [TaskScalarFieldEnum!], orderBy: [TaskOrderByWithRelationInput!], skip: Int, take: Int, where: TaskWhereInput): Task
  findFirstTeam(cursor: TeamWhereUniqueInput, distinct: [TeamScalarFieldEnum!], orderBy: [TeamOrderByWithRelationInput!], skip: Int, take: Int, where: TeamWhereInput): Team
  findFirstTeamMember(cursor: TeamMemberWhereUniqueInput, distinct: [TeamMemberScalarFieldEnum!], orderBy: [TeamMemberOrderByWithRelationInput!], skip: Int, take: Int, where: TeamMemberWhereInput): TeamMember
  findFirstTeamMemberOrThrow(cursor: TeamMemberWhereUniqueInput, distinct: [TeamMemberScalarFieldEnum!], orderBy: [TeamMemberOrderByWithRelationInput!], skip: Int, take: Int, where: TeamMemberWhereInput): TeamMember
  findFirstTeamOrThrow(cursor: TeamWhereUniqueInput, distinct: [TeamScalarFieldEnum!], orderBy: [TeamOrderByWithRelationInput!], skip: Int, take: Int, where: TeamWhereInput): Team
  findFirstTeamProject(cursor: TeamProjectWhereUniqueInput, distinct: [TeamProjectScalarFieldEnum!], orderBy: [TeamProjectOrderByWithRelationInput!], skip: Int, take: Int, where: TeamProjectWhereInput): TeamProject
  findFirstTeamProjectOrThrow(cursor: TeamProjectWhereUniqueInput, distinct: [TeamProjectScalarFieldEnum!], orderBy: [TeamProjectOrderByWithRelationInput!], skip: Int, take: Int, where: TeamProjectWhereInput): TeamProject
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findFirstUserOrThrow(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findManyTaskMasterMetadata(cursor: TaskMasterMetadataWhereUniqueInput, distinct: [TaskMasterMetadataScalarFieldEnum!], orderBy: [TaskMasterMetadataOrderByWithRelationInput!], skip: Int, take: Int, where: TaskMasterMetadataWhereInput): [TaskMasterMetadata!]!
  findUniqueTaskMasterMetadata(where: TaskMasterMetadataWhereUniqueInput!): TaskMasterMetadata
  findUniqueTaskMasterMetadataOrThrow(where: TaskMasterMetadataWhereUniqueInput!): TaskMasterMetadata
  getCycle(where: CycleWhereUniqueInput!): Cycle
  getIssue(where: IssueWhereUniqueInput!): Issue
  getIssueLabel(where: IssueLabelWhereUniqueInput!): IssueLabel
  getIssuePriority(where: IssuePriorityWhereUniqueInput!): IssuePriority
  getIssueStatus(where: IssueStatusWhereUniqueInput!): IssueStatus
  getLabel(where: LabelWhereUniqueInput!): Label
  getProject(where: ProjectWhereUniqueInput!): Project
  getSubtask(where: SubtaskWhereUniqueInput!): Subtask
  getSyncConflict(where: SyncConflictWhereUniqueInput!): SyncConflict
  getSyncOperation(where: SyncOperationWhereUniqueInput!): SyncOperation
  getTask(where: TaskWhereUniqueInput!): Task
  getTaskDependency(where: TaskDependencyWhereUniqueInput!): TaskDependency
  getTeam(where: TeamWhereUniqueInput!): Team
  getTeamMember(where: TeamMemberWhereUniqueInput!): TeamMember
  getTeamProject(where: TeamProjectWhereUniqueInput!): TeamProject
  getUser(where: UserWhereUniqueInput!): User
  groupByCycle(by: [CycleScalarFieldEnum!]!, having: CycleScalarWhereWithAggregatesInput, orderBy: [CycleOrderByWithAggregationInput!], skip: Int, take: Int, where: CycleWhereInput): [CycleGroupBy!]!
  groupByIssue(by: [IssueScalarFieldEnum!]!, having: IssueScalarWhereWithAggregatesInput, orderBy: [IssueOrderByWithAggregationInput!], skip: Int, take: Int, where: IssueWhereInput): [IssueGroupBy!]!
  groupByIssueLabel(by: [IssueLabelScalarFieldEnum!]!, having: IssueLabelScalarWhereWithAggregatesInput, orderBy: [IssueLabelOrderByWithAggregationInput!], skip: Int, take: Int, where: IssueLabelWhereInput): [IssueLabelGroupBy!]!
  groupByIssuePriority(by: [IssuePriorityScalarFieldEnum!]!, having: IssuePriorityScalarWhereWithAggregatesInput, orderBy: [IssuePriorityOrderByWithAggregationInput!], skip: Int, take: Int, where: IssuePriorityWhereInput): [IssuePriorityGroupBy!]!
  groupByIssueStatus(by: [IssueStatusScalarFieldEnum!]!, having: IssueStatusScalarWhereWithAggregatesInput, orderBy: [IssueStatusOrderByWithAggregationInput!], skip: Int, take: Int, where: IssueStatusWhereInput): [IssueStatusGroupBy!]!
  groupByLabel(by: [LabelScalarFieldEnum!]!, having: LabelScalarWhereWithAggregatesInput, orderBy: [LabelOrderByWithAggregationInput!], skip: Int, take: Int, where: LabelWhereInput): [LabelGroupBy!]!
  groupByProject(by: [ProjectScalarFieldEnum!]!, having: ProjectScalarWhereWithAggregatesInput, orderBy: [ProjectOrderByWithAggregationInput!], skip: Int, take: Int, where: ProjectWhereInput): [ProjectGroupBy!]!
  groupBySubtask(by: [SubtaskScalarFieldEnum!]!, having: SubtaskScalarWhereWithAggregatesInput, orderBy: [SubtaskOrderByWithAggregationInput!], skip: Int, take: Int, where: SubtaskWhereInput): [SubtaskGroupBy!]!
  groupBySyncConflict(by: [SyncConflictScalarFieldEnum!]!, having: SyncConflictScalarWhereWithAggregatesInput, orderBy: [SyncConflictOrderByWithAggregationInput!], skip: Int, take: Int, where: SyncConflictWhereInput): [SyncConflictGroupBy!]!
  groupBySyncOperation(by: [SyncOperationScalarFieldEnum!]!, having: SyncOperationScalarWhereWithAggregatesInput, orderBy: [SyncOperationOrderByWithAggregationInput!], skip: Int, take: Int, where: SyncOperationWhereInput): [SyncOperationGroupBy!]!
  groupByTask(by: [TaskScalarFieldEnum!]!, having: TaskScalarWhereWithAggregatesInput, orderBy: [TaskOrderByWithAggregationInput!], skip: Int, take: Int, where: TaskWhereInput): [TaskGroupBy!]!
  groupByTaskDependency(by: [TaskDependencyScalarFieldEnum!]!, having: TaskDependencyScalarWhereWithAggregatesInput, orderBy: [TaskDependencyOrderByWithAggregationInput!], skip: Int, take: Int, where: TaskDependencyWhereInput): [TaskDependencyGroupBy!]!
  groupByTaskMasterMetadata(by: [TaskMasterMetadataScalarFieldEnum!]!, having: TaskMasterMetadataScalarWhereWithAggregatesInput, orderBy: [TaskMasterMetadataOrderByWithAggregationInput!], skip: Int, take: Int, where: TaskMasterMetadataWhereInput): [TaskMasterMetadataGroupBy!]!
  groupByTeam(by: [TeamScalarFieldEnum!]!, having: TeamScalarWhereWithAggregatesInput, orderBy: [TeamOrderByWithAggregationInput!], skip: Int, take: Int, where: TeamWhereInput): [TeamGroupBy!]!
  groupByTeamMember(by: [TeamMemberScalarFieldEnum!]!, having: TeamMemberScalarWhereWithAggregatesInput, orderBy: [TeamMemberOrderByWithAggregationInput!], skip: Int, take: Int, where: TeamMemberWhereInput): [TeamMemberGroupBy!]!
  groupByTeamProject(by: [TeamProjectScalarFieldEnum!]!, having: TeamProjectScalarWhereWithAggregatesInput, orderBy: [TeamProjectOrderByWithAggregationInput!], skip: Int, take: Int, where: TeamProjectWhereInput): [TeamProjectGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  issue(where: IssueWhereUniqueInput!): Issue
  issueHealthCheck: String!
  issueLabel(where: IssueLabelWhereUniqueInput!): IssueLabel
  issueLabels(cursor: IssueLabelWhereUniqueInput, distinct: [IssueLabelScalarFieldEnum!], orderBy: [IssueLabelOrderByWithRelationInput!], skip: Int, take: Int, where: IssueLabelWhereInput): [IssueLabel!]!
  issuePriorities(cursor: IssuePriorityWhereUniqueInput, distinct: [IssuePriorityScalarFieldEnum!], orderBy: [IssuePriorityOrderByWithRelationInput!], skip: Int, take: Int, where: IssuePriorityWhereInput): [IssuePriority!]!
  issuePriority(where: IssuePriorityWhereUniqueInput!): IssuePriority
  issueStatus(where: IssueStatusWhereUniqueInput!): IssueStatus
  issueStatuses(cursor: IssueStatusWhereUniqueInput, distinct: [IssueStatusScalarFieldEnum!], orderBy: [IssueStatusOrderByWithRelationInput!], skip: Int, take: Int, where: IssueStatusWhereInput): [IssueStatus!]!
  issues(cursor: IssueWhereUniqueInput, distinct: [IssueScalarFieldEnum!], orderBy: [IssueOrderByWithRelationInput!], skip: Int, take: Int, where: IssueWhereInput): [Issue!]!
  label(where: LabelWhereUniqueInput!): Label
  labels(cursor: LabelWhereUniqueInput, distinct: [LabelScalarFieldEnum!], orderBy: [LabelOrderByWithRelationInput!], skip: Int, take: Int, where: LabelWhereInput): [Label!]!
  project(where: ProjectWhereUniqueInput!): Project
  projects(cursor: ProjectWhereUniqueInput, distinct: [ProjectScalarFieldEnum!], orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): [Project!]!
  subtask(where: SubtaskWhereUniqueInput!): Subtask
  subtasks(cursor: SubtaskWhereUniqueInput, distinct: [SubtaskScalarFieldEnum!], orderBy: [SubtaskOrderByWithRelationInput!], skip: Int, take: Int, where: SubtaskWhereInput): [Subtask!]!
  syncConflict(where: SyncConflictWhereUniqueInput!): SyncConflict
  syncConflicts(cursor: SyncConflictWhereUniqueInput, distinct: [SyncConflictScalarFieldEnum!], orderBy: [SyncConflictOrderByWithRelationInput!], skip: Int, take: Int, where: SyncConflictWhereInput): [SyncConflict!]!
  syncOperation(where: SyncOperationWhereUniqueInput!): SyncOperation
  syncOperations(cursor: SyncOperationWhereUniqueInput, distinct: [SyncOperationScalarFieldEnum!], orderBy: [SyncOperationOrderByWithRelationInput!], skip: Int, take: Int, where: SyncOperationWhereInput): [SyncOperation!]!
  task(where: TaskWhereUniqueInput!): Task
  taskDependencies(cursor: TaskDependencyWhereUniqueInput, distinct: [TaskDependencyScalarFieldEnum!], orderBy: [TaskDependencyOrderByWithRelationInput!], skip: Int, take: Int, where: TaskDependencyWhereInput): [TaskDependency!]!
  taskDependency(where: TaskDependencyWhereUniqueInput!): TaskDependency
  tasks(cursor: TaskWhereUniqueInput, distinct: [TaskScalarFieldEnum!], orderBy: [TaskOrderByWithRelationInput!], skip: Int, take: Int, where: TaskWhereInput): [Task!]!
  team(where: TeamWhereUniqueInput!): Team
  teamMember(where: TeamMemberWhereUniqueInput!): TeamMember
  teamMembers(cursor: TeamMemberWhereUniqueInput, distinct: [TeamMemberScalarFieldEnum!], orderBy: [TeamMemberOrderByWithRelationInput!], skip: Int, take: Int, where: TeamMemberWhereInput): [TeamMember!]!
  teamProject(where: TeamProjectWhereUniqueInput!): TeamProject
  teamProjects(cursor: TeamProjectWhereUniqueInput, distinct: [TeamProjectScalarFieldEnum!], orderBy: [TeamProjectOrderByWithRelationInput!], skip: Int, take: Int, where: TeamProjectWhereInput): [TeamProject!]!
  teams(cursor: TeamWhereUniqueInput, distinct: [TeamScalarFieldEnum!], orderBy: [TeamOrderByWithRelationInput!], skip: Int, take: Int, where: TeamWhereInput): [Team!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Subtask {
  _count: SubtaskCount
  createdAt: DateTime!
  dependencies: String!
  description: String!
  details: String
  id: String!
  parentId: Int!
  status: String!
  testStrategy: String
  title: String!
  updatedAt: DateTime!
}

type SubtaskAvgAggregate {
  parentId: Float
}

input SubtaskAvgOrderByAggregateInput {
  parentId: SortOrder
}

type SubtaskCount {
  issues(where: IssueWhereInput): Int!
}

type SubtaskCountAggregate {
  _all: Int!
  createdAt: Int!
  dependencies: Int!
  description: Int!
  details: Int!
  id: Int!
  parentId: Int!
  status: Int!
  testStrategy: Int!
  title: Int!
  updatedAt: Int!
}

input SubtaskCountOrderByAggregateInput {
  createdAt: SortOrder
  dependencies: SortOrder
  description: SortOrder
  details: SortOrder
  id: SortOrder
  parentId: SortOrder
  status: SortOrder
  testStrategy: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input SubtaskCreateInput {
  createdAt: DateTime
  dependencies: String
  description: String!
  details: String
  id: String!
  issues: IssueCreateNestedManyWithoutSubtaskInput
  parentTask: TaskCreateNestedOneWithoutSubtasksInput!
  status: String!
  testStrategy: String
  title: String!
  updatedAt: DateTime
}

input SubtaskCreateManyInput {
  createdAt: DateTime
  dependencies: String
  description: String!
  details: String
  id: String!
  parentId: Int!
  status: String!
  testStrategy: String
  title: String!
  updatedAt: DateTime
}

input SubtaskCreateManyParentTaskInput {
  createdAt: DateTime
  dependencies: String
  description: String!
  details: String
  id: String!
  status: String!
  testStrategy: String
  title: String!
  updatedAt: DateTime
}

input SubtaskCreateManyParentTaskInputEnvelope {
  data: [SubtaskCreateManyParentTaskInput!]!
}

input SubtaskCreateNestedManyWithoutParentTaskInput {
  connect: [SubtaskWhereUniqueInput!]
  connectOrCreate: [SubtaskCreateOrConnectWithoutParentTaskInput!]
  create: [SubtaskCreateWithoutParentTaskInput!]
  createMany: SubtaskCreateManyParentTaskInputEnvelope
}

input SubtaskCreateNestedOneWithoutIssuesInput {
  connect: SubtaskWhereUniqueInput
  connectOrCreate: SubtaskCreateOrConnectWithoutIssuesInput
  create: SubtaskCreateWithoutIssuesInput
}

input SubtaskCreateOrConnectWithoutIssuesInput {
  create: SubtaskCreateWithoutIssuesInput!
  where: SubtaskWhereUniqueInput!
}

input SubtaskCreateOrConnectWithoutParentTaskInput {
  create: SubtaskCreateWithoutParentTaskInput!
  where: SubtaskWhereUniqueInput!
}

input SubtaskCreateWithoutIssuesInput {
  createdAt: DateTime
  dependencies: String
  description: String!
  details: String
  id: String!
  parentTask: TaskCreateNestedOneWithoutSubtasksInput!
  status: String!
  testStrategy: String
  title: String!
  updatedAt: DateTime
}

input SubtaskCreateWithoutParentTaskInput {
  createdAt: DateTime
  dependencies: String
  description: String!
  details: String
  id: String!
  issues: IssueCreateNestedManyWithoutSubtaskInput
  status: String!
  testStrategy: String
  title: String!
  updatedAt: DateTime
}

type SubtaskGroupBy {
  _avg: SubtaskAvgAggregate
  _count: SubtaskCountAggregate
  _max: SubtaskMaxAggregate
  _min: SubtaskMinAggregate
  _sum: SubtaskSumAggregate
  createdAt: DateTime!
  dependencies: String!
  description: String!
  details: String
  id: String!
  parentId: Int!
  status: String!
  testStrategy: String
  title: String!
  updatedAt: DateTime!
}

input SubtaskListRelationFilter {
  every: SubtaskWhereInput
  none: SubtaskWhereInput
  some: SubtaskWhereInput
}

type SubtaskMaxAggregate {
  createdAt: DateTime
  dependencies: String
  description: String
  details: String
  id: String
  parentId: Int
  status: String
  testStrategy: String
  title: String
  updatedAt: DateTime
}

input SubtaskMaxOrderByAggregateInput {
  createdAt: SortOrder
  dependencies: SortOrder
  description: SortOrder
  details: SortOrder
  id: SortOrder
  parentId: SortOrder
  status: SortOrder
  testStrategy: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

type SubtaskMinAggregate {
  createdAt: DateTime
  dependencies: String
  description: String
  details: String
  id: String
  parentId: Int
  status: String
  testStrategy: String
  title: String
  updatedAt: DateTime
}

input SubtaskMinOrderByAggregateInput {
  createdAt: SortOrder
  dependencies: SortOrder
  description: SortOrder
  details: SortOrder
  id: SortOrder
  parentId: SortOrder
  status: SortOrder
  testStrategy: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input SubtaskNullableRelationFilter {
  is: SubtaskWhereInput
  isNot: SubtaskWhereInput
}

input SubtaskOrderByRelationAggregateInput {
  _count: SortOrder
}

input SubtaskOrderByWithAggregationInput {
  _avg: SubtaskAvgOrderByAggregateInput
  _count: SubtaskCountOrderByAggregateInput
  _max: SubtaskMaxOrderByAggregateInput
  _min: SubtaskMinOrderByAggregateInput
  _sum: SubtaskSumOrderByAggregateInput
  createdAt: SortOrder
  dependencies: SortOrder
  description: SortOrder
  details: SortOrderInput
  id: SortOrder
  parentId: SortOrder
  status: SortOrder
  testStrategy: SortOrderInput
  title: SortOrder
  updatedAt: SortOrder
}

input SubtaskOrderByWithRelationInput {
  createdAt: SortOrder
  dependencies: SortOrder
  description: SortOrder
  details: SortOrderInput
  id: SortOrder
  issues: IssueOrderByRelationAggregateInput
  parentId: SortOrder
  parentTask: TaskOrderByWithRelationInput
  status: SortOrder
  testStrategy: SortOrderInput
  title: SortOrder
  updatedAt: SortOrder
}

enum SubtaskScalarFieldEnum {
  createdAt
  dependencies
  description
  details
  id
  parentId
  status
  testStrategy
  title
  updatedAt
}

input SubtaskScalarWhereInput {
  AND: [SubtaskScalarWhereInput!]
  NOT: [SubtaskScalarWhereInput!]
  OR: [SubtaskScalarWhereInput!]
  createdAt: DateTimeFilter
  dependencies: StringFilter
  description: StringFilter
  details: StringNullableFilter
  id: StringFilter
  parentId: IntFilter
  status: StringFilter
  testStrategy: StringNullableFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input SubtaskScalarWhereWithAggregatesInput {
  AND: [SubtaskScalarWhereWithAggregatesInput!]
  NOT: [SubtaskScalarWhereWithAggregatesInput!]
  OR: [SubtaskScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  dependencies: StringWithAggregatesFilter
  description: StringWithAggregatesFilter
  details: StringNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  parentId: IntWithAggregatesFilter
  status: StringWithAggregatesFilter
  testStrategy: StringNullableWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type SubtaskSumAggregate {
  parentId: Int
}

input SubtaskSumOrderByAggregateInput {
  parentId: SortOrder
}

input SubtaskUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  dependencies: StringFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  details: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  issues: IssueUpdateManyWithoutSubtaskNestedInput
  parentTask: TaskUpdateOneRequiredWithoutSubtasksNestedInput
  status: StringFieldUpdateOperationsInput
  testStrategy: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SubtaskUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  dependencies: StringFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  details: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
  testStrategy: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SubtaskUpdateManyWithWhereWithoutParentTaskInput {
  data: SubtaskUpdateManyMutationInput!
  where: SubtaskScalarWhereInput!
}

input SubtaskUpdateManyWithoutParentTaskNestedInput {
  connect: [SubtaskWhereUniqueInput!]
  connectOrCreate: [SubtaskCreateOrConnectWithoutParentTaskInput!]
  create: [SubtaskCreateWithoutParentTaskInput!]
  createMany: SubtaskCreateManyParentTaskInputEnvelope
  delete: [SubtaskWhereUniqueInput!]
  deleteMany: [SubtaskScalarWhereInput!]
  disconnect: [SubtaskWhereUniqueInput!]
  set: [SubtaskWhereUniqueInput!]
  update: [SubtaskUpdateWithWhereUniqueWithoutParentTaskInput!]
  updateMany: [SubtaskUpdateManyWithWhereWithoutParentTaskInput!]
  upsert: [SubtaskUpsertWithWhereUniqueWithoutParentTaskInput!]
}

input SubtaskUpdateOneWithoutIssuesNestedInput {
  connect: SubtaskWhereUniqueInput
  connectOrCreate: SubtaskCreateOrConnectWithoutIssuesInput
  create: SubtaskCreateWithoutIssuesInput
  delete: SubtaskWhereInput
  disconnect: SubtaskWhereInput
  update: SubtaskUpdateToOneWithWhereWithoutIssuesInput
  upsert: SubtaskUpsertWithoutIssuesInput
}

input SubtaskUpdateToOneWithWhereWithoutIssuesInput {
  data: SubtaskUpdateWithoutIssuesInput!
  where: SubtaskWhereInput
}

input SubtaskUpdateWithWhereUniqueWithoutParentTaskInput {
  data: SubtaskUpdateWithoutParentTaskInput!
  where: SubtaskWhereUniqueInput!
}

input SubtaskUpdateWithoutIssuesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  dependencies: StringFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  details: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  parentTask: TaskUpdateOneRequiredWithoutSubtasksNestedInput
  status: StringFieldUpdateOperationsInput
  testStrategy: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SubtaskUpdateWithoutParentTaskInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  dependencies: StringFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  details: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  issues: IssueUpdateManyWithoutSubtaskNestedInput
  status: StringFieldUpdateOperationsInput
  testStrategy: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SubtaskUpsertWithWhereUniqueWithoutParentTaskInput {
  create: SubtaskCreateWithoutParentTaskInput!
  update: SubtaskUpdateWithoutParentTaskInput!
  where: SubtaskWhereUniqueInput!
}

input SubtaskUpsertWithoutIssuesInput {
  create: SubtaskCreateWithoutIssuesInput!
  update: SubtaskUpdateWithoutIssuesInput!
  where: SubtaskWhereInput
}

input SubtaskWhereInput {
  AND: [SubtaskWhereInput!]
  NOT: [SubtaskWhereInput!]
  OR: [SubtaskWhereInput!]
  createdAt: DateTimeFilter
  dependencies: StringFilter
  description: StringFilter
  details: StringNullableFilter
  id: StringFilter
  issues: IssueListRelationFilter
  parentId: IntFilter
  parentTask: TaskRelationFilter
  status: StringFilter
  testStrategy: StringNullableFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input SubtaskWhereUniqueInput {
  AND: [SubtaskWhereInput!]
  NOT: [SubtaskWhereInput!]
  OR: [SubtaskWhereInput!]
  createdAt: DateTimeFilter
  dependencies: StringFilter
  description: StringFilter
  details: StringNullableFilter
  id: String
  issues: IssueListRelationFilter
  parentId: IntFilter
  parentTask: TaskRelationFilter
  status: StringFilter
  testStrategy: StringNullableFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

type SyncConflict {
  cliVersion: String!
  id: String!
  operationType: String!
  resolution: String
  resolved: Boolean!
  resolvedAt: DateTime
  resolvedBy: String
  taskId: String!
  timestamp: DateTime!
  uiVersion: String!
}

type SyncConflictCountAggregate {
  _all: Int!
  cliVersion: Int!
  id: Int!
  operationType: Int!
  resolution: Int!
  resolved: Int!
  resolvedAt: Int!
  resolvedBy: Int!
  taskId: Int!
  timestamp: Int!
  uiVersion: Int!
}

input SyncConflictCountOrderByAggregateInput {
  cliVersion: SortOrder
  id: SortOrder
  operationType: SortOrder
  resolution: SortOrder
  resolved: SortOrder
  resolvedAt: SortOrder
  resolvedBy: SortOrder
  taskId: SortOrder
  timestamp: SortOrder
  uiVersion: SortOrder
}

input SyncConflictCreateInput {
  cliVersion: String!
  id: String
  operationType: String!
  resolution: String
  resolved: Boolean
  resolvedAt: DateTime
  resolvedBy: String
  taskId: String!
  timestamp: DateTime
  uiVersion: String!
}

input SyncConflictCreateManyInput {
  cliVersion: String!
  id: String
  operationType: String!
  resolution: String
  resolved: Boolean
  resolvedAt: DateTime
  resolvedBy: String
  taskId: String!
  timestamp: DateTime
  uiVersion: String!
}

type SyncConflictGroupBy {
  _count: SyncConflictCountAggregate
  _max: SyncConflictMaxAggregate
  _min: SyncConflictMinAggregate
  cliVersion: String!
  id: String!
  operationType: String!
  resolution: String
  resolved: Boolean!
  resolvedAt: DateTime
  resolvedBy: String
  taskId: String!
  timestamp: DateTime!
  uiVersion: String!
}

type SyncConflictMaxAggregate {
  cliVersion: String
  id: String
  operationType: String
  resolution: String
  resolved: Boolean
  resolvedAt: DateTime
  resolvedBy: String
  taskId: String
  timestamp: DateTime
  uiVersion: String
}

input SyncConflictMaxOrderByAggregateInput {
  cliVersion: SortOrder
  id: SortOrder
  operationType: SortOrder
  resolution: SortOrder
  resolved: SortOrder
  resolvedAt: SortOrder
  resolvedBy: SortOrder
  taskId: SortOrder
  timestamp: SortOrder
  uiVersion: SortOrder
}

type SyncConflictMinAggregate {
  cliVersion: String
  id: String
  operationType: String
  resolution: String
  resolved: Boolean
  resolvedAt: DateTime
  resolvedBy: String
  taskId: String
  timestamp: DateTime
  uiVersion: String
}

input SyncConflictMinOrderByAggregateInput {
  cliVersion: SortOrder
  id: SortOrder
  operationType: SortOrder
  resolution: SortOrder
  resolved: SortOrder
  resolvedAt: SortOrder
  resolvedBy: SortOrder
  taskId: SortOrder
  timestamp: SortOrder
  uiVersion: SortOrder
}

input SyncConflictOrderByWithAggregationInput {
  _count: SyncConflictCountOrderByAggregateInput
  _max: SyncConflictMaxOrderByAggregateInput
  _min: SyncConflictMinOrderByAggregateInput
  cliVersion: SortOrder
  id: SortOrder
  operationType: SortOrder
  resolution: SortOrderInput
  resolved: SortOrder
  resolvedAt: SortOrderInput
  resolvedBy: SortOrderInput
  taskId: SortOrder
  timestamp: SortOrder
  uiVersion: SortOrder
}

input SyncConflictOrderByWithRelationInput {
  cliVersion: SortOrder
  id: SortOrder
  operationType: SortOrder
  resolution: SortOrderInput
  resolved: SortOrder
  resolvedAt: SortOrderInput
  resolvedBy: SortOrderInput
  taskId: SortOrder
  timestamp: SortOrder
  uiVersion: SortOrder
}

enum SyncConflictScalarFieldEnum {
  cliVersion
  id
  operationType
  resolution
  resolved
  resolvedAt
  resolvedBy
  taskId
  timestamp
  uiVersion
}

input SyncConflictScalarWhereWithAggregatesInput {
  AND: [SyncConflictScalarWhereWithAggregatesInput!]
  NOT: [SyncConflictScalarWhereWithAggregatesInput!]
  OR: [SyncConflictScalarWhereWithAggregatesInput!]
  cliVersion: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  operationType: StringWithAggregatesFilter
  resolution: StringNullableWithAggregatesFilter
  resolved: BoolWithAggregatesFilter
  resolvedAt: DateTimeNullableWithAggregatesFilter
  resolvedBy: StringNullableWithAggregatesFilter
  taskId: StringWithAggregatesFilter
  timestamp: DateTimeWithAggregatesFilter
  uiVersion: StringWithAggregatesFilter
}

input SyncConflictUpdateInput {
  cliVersion: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  operationType: StringFieldUpdateOperationsInput
  resolution: NullableStringFieldUpdateOperationsInput
  resolved: BoolFieldUpdateOperationsInput
  resolvedAt: NullableDateTimeFieldUpdateOperationsInput
  resolvedBy: NullableStringFieldUpdateOperationsInput
  taskId: StringFieldUpdateOperationsInput
  timestamp: DateTimeFieldUpdateOperationsInput
  uiVersion: StringFieldUpdateOperationsInput
}

input SyncConflictUpdateManyMutationInput {
  cliVersion: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  operationType: StringFieldUpdateOperationsInput
  resolution: NullableStringFieldUpdateOperationsInput
  resolved: BoolFieldUpdateOperationsInput
  resolvedAt: NullableDateTimeFieldUpdateOperationsInput
  resolvedBy: NullableStringFieldUpdateOperationsInput
  taskId: StringFieldUpdateOperationsInput
  timestamp: DateTimeFieldUpdateOperationsInput
  uiVersion: StringFieldUpdateOperationsInput
}

input SyncConflictWhereInput {
  AND: [SyncConflictWhereInput!]
  NOT: [SyncConflictWhereInput!]
  OR: [SyncConflictWhereInput!]
  cliVersion: StringFilter
  id: StringFilter
  operationType: StringFilter
  resolution: StringNullableFilter
  resolved: BoolFilter
  resolvedAt: DateTimeNullableFilter
  resolvedBy: StringNullableFilter
  taskId: StringFilter
  timestamp: DateTimeFilter
  uiVersion: StringFilter
}

input SyncConflictWhereUniqueInput {
  AND: [SyncConflictWhereInput!]
  NOT: [SyncConflictWhereInput!]
  OR: [SyncConflictWhereInput!]
  cliVersion: StringFilter
  id: String
  operationType: StringFilter
  resolution: StringNullableFilter
  resolved: BoolFilter
  resolvedAt: DateTimeNullableFilter
  resolvedBy: StringNullableFilter
  taskId: StringFilter
  timestamp: DateTimeFilter
  uiVersion: StringFilter
}

type SyncOperation {
  completedAt: DateTime
  data: String!
  error: String
  id: String!
  maxRetries: Int!
  metadata: String
  retryCount: Int!
  rollbackData: String
  source: String!
  status: String!
  taskIds: String!
  timestamp: DateTime!
  type: String!
}

type SyncOperationAvgAggregate {
  maxRetries: Float
  retryCount: Float
}

input SyncOperationAvgOrderByAggregateInput {
  maxRetries: SortOrder
  retryCount: SortOrder
}

type SyncOperationCountAggregate {
  _all: Int!
  completedAt: Int!
  data: Int!
  error: Int!
  id: Int!
  maxRetries: Int!
  metadata: Int!
  retryCount: Int!
  rollbackData: Int!
  source: Int!
  status: Int!
  taskIds: Int!
  timestamp: Int!
  type: Int!
}

input SyncOperationCountOrderByAggregateInput {
  completedAt: SortOrder
  data: SortOrder
  error: SortOrder
  id: SortOrder
  maxRetries: SortOrder
  metadata: SortOrder
  retryCount: SortOrder
  rollbackData: SortOrder
  source: SortOrder
  status: SortOrder
  taskIds: SortOrder
  timestamp: SortOrder
  type: SortOrder
}

input SyncOperationCreateInput {
  completedAt: DateTime
  data: String!
  error: String
  id: String
  maxRetries: Int
  metadata: String
  retryCount: Int
  rollbackData: String
  source: String!
  status: String!
  taskIds: String
  timestamp: DateTime
  type: String!
}

input SyncOperationCreateManyInput {
  completedAt: DateTime
  data: String!
  error: String
  id: String
  maxRetries: Int
  metadata: String
  retryCount: Int
  rollbackData: String
  source: String!
  status: String!
  taskIds: String
  timestamp: DateTime
  type: String!
}

type SyncOperationGroupBy {
  _avg: SyncOperationAvgAggregate
  _count: SyncOperationCountAggregate
  _max: SyncOperationMaxAggregate
  _min: SyncOperationMinAggregate
  _sum: SyncOperationSumAggregate
  completedAt: DateTime
  data: String!
  error: String
  id: String!
  maxRetries: Int!
  metadata: String
  retryCount: Int!
  rollbackData: String
  source: String!
  status: String!
  taskIds: String!
  timestamp: DateTime!
  type: String!
}

type SyncOperationMaxAggregate {
  completedAt: DateTime
  data: String
  error: String
  id: String
  maxRetries: Int
  metadata: String
  retryCount: Int
  rollbackData: String
  source: String
  status: String
  taskIds: String
  timestamp: DateTime
  type: String
}

input SyncOperationMaxOrderByAggregateInput {
  completedAt: SortOrder
  data: SortOrder
  error: SortOrder
  id: SortOrder
  maxRetries: SortOrder
  metadata: SortOrder
  retryCount: SortOrder
  rollbackData: SortOrder
  source: SortOrder
  status: SortOrder
  taskIds: SortOrder
  timestamp: SortOrder
  type: SortOrder
}

type SyncOperationMinAggregate {
  completedAt: DateTime
  data: String
  error: String
  id: String
  maxRetries: Int
  metadata: String
  retryCount: Int
  rollbackData: String
  source: String
  status: String
  taskIds: String
  timestamp: DateTime
  type: String
}

input SyncOperationMinOrderByAggregateInput {
  completedAt: SortOrder
  data: SortOrder
  error: SortOrder
  id: SortOrder
  maxRetries: SortOrder
  metadata: SortOrder
  retryCount: SortOrder
  rollbackData: SortOrder
  source: SortOrder
  status: SortOrder
  taskIds: SortOrder
  timestamp: SortOrder
  type: SortOrder
}

input SyncOperationOrderByWithAggregationInput {
  _avg: SyncOperationAvgOrderByAggregateInput
  _count: SyncOperationCountOrderByAggregateInput
  _max: SyncOperationMaxOrderByAggregateInput
  _min: SyncOperationMinOrderByAggregateInput
  _sum: SyncOperationSumOrderByAggregateInput
  completedAt: SortOrderInput
  data: SortOrder
  error: SortOrderInput
  id: SortOrder
  maxRetries: SortOrder
  metadata: SortOrderInput
  retryCount: SortOrder
  rollbackData: SortOrderInput
  source: SortOrder
  status: SortOrder
  taskIds: SortOrder
  timestamp: SortOrder
  type: SortOrder
}

input SyncOperationOrderByWithRelationInput {
  completedAt: SortOrderInput
  data: SortOrder
  error: SortOrderInput
  id: SortOrder
  maxRetries: SortOrder
  metadata: SortOrderInput
  retryCount: SortOrder
  rollbackData: SortOrderInput
  source: SortOrder
  status: SortOrder
  taskIds: SortOrder
  timestamp: SortOrder
  type: SortOrder
}

enum SyncOperationScalarFieldEnum {
  completedAt
  data
  error
  id
  maxRetries
  metadata
  retryCount
  rollbackData
  source
  status
  taskIds
  timestamp
  type
}

input SyncOperationScalarWhereWithAggregatesInput {
  AND: [SyncOperationScalarWhereWithAggregatesInput!]
  NOT: [SyncOperationScalarWhereWithAggregatesInput!]
  OR: [SyncOperationScalarWhereWithAggregatesInput!]
  completedAt: DateTimeNullableWithAggregatesFilter
  data: StringWithAggregatesFilter
  error: StringNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  maxRetries: IntWithAggregatesFilter
  metadata: StringNullableWithAggregatesFilter
  retryCount: IntWithAggregatesFilter
  rollbackData: StringNullableWithAggregatesFilter
  source: StringWithAggregatesFilter
  status: StringWithAggregatesFilter
  taskIds: StringWithAggregatesFilter
  timestamp: DateTimeWithAggregatesFilter
  type: StringWithAggregatesFilter
}

type SyncOperationSumAggregate {
  maxRetries: Int
  retryCount: Int
}

input SyncOperationSumOrderByAggregateInput {
  maxRetries: SortOrder
  retryCount: SortOrder
}

input SyncOperationUpdateInput {
  completedAt: NullableDateTimeFieldUpdateOperationsInput
  data: StringFieldUpdateOperationsInput
  error: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  maxRetries: IntFieldUpdateOperationsInput
  metadata: NullableStringFieldUpdateOperationsInput
  retryCount: IntFieldUpdateOperationsInput
  rollbackData: NullableStringFieldUpdateOperationsInput
  source: StringFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
  taskIds: StringFieldUpdateOperationsInput
  timestamp: DateTimeFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input SyncOperationUpdateManyMutationInput {
  completedAt: NullableDateTimeFieldUpdateOperationsInput
  data: StringFieldUpdateOperationsInput
  error: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  maxRetries: IntFieldUpdateOperationsInput
  metadata: NullableStringFieldUpdateOperationsInput
  retryCount: IntFieldUpdateOperationsInput
  rollbackData: NullableStringFieldUpdateOperationsInput
  source: StringFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
  taskIds: StringFieldUpdateOperationsInput
  timestamp: DateTimeFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input SyncOperationWhereInput {
  AND: [SyncOperationWhereInput!]
  NOT: [SyncOperationWhereInput!]
  OR: [SyncOperationWhereInput!]
  completedAt: DateTimeNullableFilter
  data: StringFilter
  error: StringNullableFilter
  id: StringFilter
  maxRetries: IntFilter
  metadata: StringNullableFilter
  retryCount: IntFilter
  rollbackData: StringNullableFilter
  source: StringFilter
  status: StringFilter
  taskIds: StringFilter
  timestamp: DateTimeFilter
  type: StringFilter
}

input SyncOperationWhereUniqueInput {
  AND: [SyncOperationWhereInput!]
  NOT: [SyncOperationWhereInput!]
  OR: [SyncOperationWhereInput!]
  completedAt: DateTimeNullableFilter
  data: StringFilter
  error: StringNullableFilter
  id: String
  maxRetries: IntFilter
  metadata: StringNullableFilter
  retryCount: IntFilter
  rollbackData: StringNullableFilter
  source: StringFilter
  status: StringFilter
  taskIds: StringFilter
  timestamp: DateTimeFilter
  type: StringFilter
}

type Task {
  _count: TaskCount
  complexity: Int
  createdAt: DateTime!
  description: String!
  details: String
  id: Int!
  priority: String!
  status: String!
  testStrategy: String
  title: String!
  updatedAt: DateTime!
}

type TaskAvgAggregate {
  complexity: Float
  id: Float
}

input TaskAvgOrderByAggregateInput {
  complexity: SortOrder
  id: SortOrder
}

type TaskCount {
  dependencies(where: TaskDependencyWhereInput): Int!
  dependents(where: TaskDependencyWhereInput): Int!
  issues(where: IssueWhereInput): Int!
  subtasks(where: SubtaskWhereInput): Int!
}

type TaskCountAggregate {
  _all: Int!
  complexity: Int!
  createdAt: Int!
  description: Int!
  details: Int!
  id: Int!
  priority: Int!
  status: Int!
  testStrategy: Int!
  title: Int!
  updatedAt: Int!
}

input TaskCountOrderByAggregateInput {
  complexity: SortOrder
  createdAt: SortOrder
  description: SortOrder
  details: SortOrder
  id: SortOrder
  priority: SortOrder
  status: SortOrder
  testStrategy: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input TaskCreateInput {
  complexity: Int
  createdAt: DateTime
  dependencies: TaskDependencyCreateNestedManyWithoutTaskInput
  dependents: TaskDependencyCreateNestedManyWithoutDependsOnInput
  description: String!
  details: String
  id: Int!
  issues: IssueCreateNestedManyWithoutTaskInput
  priority: String!
  status: String!
  subtasks: SubtaskCreateNestedManyWithoutParentTaskInput
  testStrategy: String
  title: String!
  updatedAt: DateTime
}

input TaskCreateManyInput {
  complexity: Int
  createdAt: DateTime
  description: String!
  details: String
  id: Int!
  priority: String!
  status: String!
  testStrategy: String
  title: String!
  updatedAt: DateTime
}

input TaskCreateNestedOneWithoutDependenciesInput {
  connect: TaskWhereUniqueInput
  connectOrCreate: TaskCreateOrConnectWithoutDependenciesInput
  create: TaskCreateWithoutDependenciesInput
}

input TaskCreateNestedOneWithoutDependentsInput {
  connect: TaskWhereUniqueInput
  connectOrCreate: TaskCreateOrConnectWithoutDependentsInput
  create: TaskCreateWithoutDependentsInput
}

input TaskCreateNestedOneWithoutIssuesInput {
  connect: TaskWhereUniqueInput
  connectOrCreate: TaskCreateOrConnectWithoutIssuesInput
  create: TaskCreateWithoutIssuesInput
}

input TaskCreateNestedOneWithoutSubtasksInput {
  connect: TaskWhereUniqueInput
  connectOrCreate: TaskCreateOrConnectWithoutSubtasksInput
  create: TaskCreateWithoutSubtasksInput
}

input TaskCreateOrConnectWithoutDependenciesInput {
  create: TaskCreateWithoutDependenciesInput!
  where: TaskWhereUniqueInput!
}

input TaskCreateOrConnectWithoutDependentsInput {
  create: TaskCreateWithoutDependentsInput!
  where: TaskWhereUniqueInput!
}

input TaskCreateOrConnectWithoutIssuesInput {
  create: TaskCreateWithoutIssuesInput!
  where: TaskWhereUniqueInput!
}

input TaskCreateOrConnectWithoutSubtasksInput {
  create: TaskCreateWithoutSubtasksInput!
  where: TaskWhereUniqueInput!
}

input TaskCreateWithoutDependenciesInput {
  complexity: Int
  createdAt: DateTime
  dependents: TaskDependencyCreateNestedManyWithoutDependsOnInput
  description: String!
  details: String
  id: Int!
  issues: IssueCreateNestedManyWithoutTaskInput
  priority: String!
  status: String!
  subtasks: SubtaskCreateNestedManyWithoutParentTaskInput
  testStrategy: String
  title: String!
  updatedAt: DateTime
}

input TaskCreateWithoutDependentsInput {
  complexity: Int
  createdAt: DateTime
  dependencies: TaskDependencyCreateNestedManyWithoutTaskInput
  description: String!
  details: String
  id: Int!
  issues: IssueCreateNestedManyWithoutTaskInput
  priority: String!
  status: String!
  subtasks: SubtaskCreateNestedManyWithoutParentTaskInput
  testStrategy: String
  title: String!
  updatedAt: DateTime
}

input TaskCreateWithoutIssuesInput {
  complexity: Int
  createdAt: DateTime
  dependencies: TaskDependencyCreateNestedManyWithoutTaskInput
  dependents: TaskDependencyCreateNestedManyWithoutDependsOnInput
  description: String!
  details: String
  id: Int!
  priority: String!
  status: String!
  subtasks: SubtaskCreateNestedManyWithoutParentTaskInput
  testStrategy: String
  title: String!
  updatedAt: DateTime
}

input TaskCreateWithoutSubtasksInput {
  complexity: Int
  createdAt: DateTime
  dependencies: TaskDependencyCreateNestedManyWithoutTaskInput
  dependents: TaskDependencyCreateNestedManyWithoutDependsOnInput
  description: String!
  details: String
  id: Int!
  issues: IssueCreateNestedManyWithoutTaskInput
  priority: String!
  status: String!
  testStrategy: String
  title: String!
  updatedAt: DateTime
}

type TaskDependency {
  createdAt: DateTime!
  dependsOnId: Int!
  id: Int!
  taskId: Int!
}

type TaskDependencyAvgAggregate {
  dependsOnId: Float
  id: Float
  taskId: Float
}

input TaskDependencyAvgOrderByAggregateInput {
  dependsOnId: SortOrder
  id: SortOrder
  taskId: SortOrder
}

type TaskDependencyCountAggregate {
  _all: Int!
  createdAt: Int!
  dependsOnId: Int!
  id: Int!
  taskId: Int!
}

input TaskDependencyCountOrderByAggregateInput {
  createdAt: SortOrder
  dependsOnId: SortOrder
  id: SortOrder
  taskId: SortOrder
}

input TaskDependencyCreateInput {
  createdAt: DateTime
  dependsOn: TaskCreateNestedOneWithoutDependentsInput!
  task: TaskCreateNestedOneWithoutDependenciesInput!
}

input TaskDependencyCreateManyDependsOnInput {
  createdAt: DateTime
  id: Int
  taskId: Int!
}

input TaskDependencyCreateManyDependsOnInputEnvelope {
  data: [TaskDependencyCreateManyDependsOnInput!]!
}

input TaskDependencyCreateManyInput {
  createdAt: DateTime
  dependsOnId: Int!
  id: Int
  taskId: Int!
}

input TaskDependencyCreateManyTaskInput {
  createdAt: DateTime
  dependsOnId: Int!
  id: Int
}

input TaskDependencyCreateManyTaskInputEnvelope {
  data: [TaskDependencyCreateManyTaskInput!]!
}

input TaskDependencyCreateNestedManyWithoutDependsOnInput {
  connect: [TaskDependencyWhereUniqueInput!]
  connectOrCreate: [TaskDependencyCreateOrConnectWithoutDependsOnInput!]
  create: [TaskDependencyCreateWithoutDependsOnInput!]
  createMany: TaskDependencyCreateManyDependsOnInputEnvelope
}

input TaskDependencyCreateNestedManyWithoutTaskInput {
  connect: [TaskDependencyWhereUniqueInput!]
  connectOrCreate: [TaskDependencyCreateOrConnectWithoutTaskInput!]
  create: [TaskDependencyCreateWithoutTaskInput!]
  createMany: TaskDependencyCreateManyTaskInputEnvelope
}

input TaskDependencyCreateOrConnectWithoutDependsOnInput {
  create: TaskDependencyCreateWithoutDependsOnInput!
  where: TaskDependencyWhereUniqueInput!
}

input TaskDependencyCreateOrConnectWithoutTaskInput {
  create: TaskDependencyCreateWithoutTaskInput!
  where: TaskDependencyWhereUniqueInput!
}

input TaskDependencyCreateWithoutDependsOnInput {
  createdAt: DateTime
  task: TaskCreateNestedOneWithoutDependenciesInput!
}

input TaskDependencyCreateWithoutTaskInput {
  createdAt: DateTime
  dependsOn: TaskCreateNestedOneWithoutDependentsInput!
}

type TaskDependencyGroupBy {
  _avg: TaskDependencyAvgAggregate
  _count: TaskDependencyCountAggregate
  _max: TaskDependencyMaxAggregate
  _min: TaskDependencyMinAggregate
  _sum: TaskDependencySumAggregate
  createdAt: DateTime!
  dependsOnId: Int!
  id: Int!
  taskId: Int!
}

input TaskDependencyListRelationFilter {
  every: TaskDependencyWhereInput
  none: TaskDependencyWhereInput
  some: TaskDependencyWhereInput
}

type TaskDependencyMaxAggregate {
  createdAt: DateTime
  dependsOnId: Int
  id: Int
  taskId: Int
}

input TaskDependencyMaxOrderByAggregateInput {
  createdAt: SortOrder
  dependsOnId: SortOrder
  id: SortOrder
  taskId: SortOrder
}

type TaskDependencyMinAggregate {
  createdAt: DateTime
  dependsOnId: Int
  id: Int
  taskId: Int
}

input TaskDependencyMinOrderByAggregateInput {
  createdAt: SortOrder
  dependsOnId: SortOrder
  id: SortOrder
  taskId: SortOrder
}

input TaskDependencyOrderByRelationAggregateInput {
  _count: SortOrder
}

input TaskDependencyOrderByWithAggregationInput {
  _avg: TaskDependencyAvgOrderByAggregateInput
  _count: TaskDependencyCountOrderByAggregateInput
  _max: TaskDependencyMaxOrderByAggregateInput
  _min: TaskDependencyMinOrderByAggregateInput
  _sum: TaskDependencySumOrderByAggregateInput
  createdAt: SortOrder
  dependsOnId: SortOrder
  id: SortOrder
  taskId: SortOrder
}

input TaskDependencyOrderByWithRelationInput {
  createdAt: SortOrder
  dependsOn: TaskOrderByWithRelationInput
  dependsOnId: SortOrder
  id: SortOrder
  task: TaskOrderByWithRelationInput
  taskId: SortOrder
}

enum TaskDependencyScalarFieldEnum {
  createdAt
  dependsOnId
  id
  taskId
}

input TaskDependencyScalarWhereInput {
  AND: [TaskDependencyScalarWhereInput!]
  NOT: [TaskDependencyScalarWhereInput!]
  OR: [TaskDependencyScalarWhereInput!]
  createdAt: DateTimeFilter
  dependsOnId: IntFilter
  id: IntFilter
  taskId: IntFilter
}

input TaskDependencyScalarWhereWithAggregatesInput {
  AND: [TaskDependencyScalarWhereWithAggregatesInput!]
  NOT: [TaskDependencyScalarWhereWithAggregatesInput!]
  OR: [TaskDependencyScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  dependsOnId: IntWithAggregatesFilter
  id: IntWithAggregatesFilter
  taskId: IntWithAggregatesFilter
}

type TaskDependencySumAggregate {
  dependsOnId: Int
  id: Int
  taskId: Int
}

input TaskDependencySumOrderByAggregateInput {
  dependsOnId: SortOrder
  id: SortOrder
  taskId: SortOrder
}

input TaskDependencyTaskIdDependsOnIdCompoundUniqueInput {
  dependsOnId: Int!
  taskId: Int!
}

input TaskDependencyUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  dependsOn: TaskUpdateOneRequiredWithoutDependentsNestedInput
  task: TaskUpdateOneRequiredWithoutDependenciesNestedInput
}

input TaskDependencyUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
}

input TaskDependencyUpdateManyWithWhereWithoutDependsOnInput {
  data: TaskDependencyUpdateManyMutationInput!
  where: TaskDependencyScalarWhereInput!
}

input TaskDependencyUpdateManyWithWhereWithoutTaskInput {
  data: TaskDependencyUpdateManyMutationInput!
  where: TaskDependencyScalarWhereInput!
}

input TaskDependencyUpdateManyWithoutDependsOnNestedInput {
  connect: [TaskDependencyWhereUniqueInput!]
  connectOrCreate: [TaskDependencyCreateOrConnectWithoutDependsOnInput!]
  create: [TaskDependencyCreateWithoutDependsOnInput!]
  createMany: TaskDependencyCreateManyDependsOnInputEnvelope
  delete: [TaskDependencyWhereUniqueInput!]
  deleteMany: [TaskDependencyScalarWhereInput!]
  disconnect: [TaskDependencyWhereUniqueInput!]
  set: [TaskDependencyWhereUniqueInput!]
  update: [TaskDependencyUpdateWithWhereUniqueWithoutDependsOnInput!]
  updateMany: [TaskDependencyUpdateManyWithWhereWithoutDependsOnInput!]
  upsert: [TaskDependencyUpsertWithWhereUniqueWithoutDependsOnInput!]
}

input TaskDependencyUpdateManyWithoutTaskNestedInput {
  connect: [TaskDependencyWhereUniqueInput!]
  connectOrCreate: [TaskDependencyCreateOrConnectWithoutTaskInput!]
  create: [TaskDependencyCreateWithoutTaskInput!]
  createMany: TaskDependencyCreateManyTaskInputEnvelope
  delete: [TaskDependencyWhereUniqueInput!]
  deleteMany: [TaskDependencyScalarWhereInput!]
  disconnect: [TaskDependencyWhereUniqueInput!]
  set: [TaskDependencyWhereUniqueInput!]
  update: [TaskDependencyUpdateWithWhereUniqueWithoutTaskInput!]
  updateMany: [TaskDependencyUpdateManyWithWhereWithoutTaskInput!]
  upsert: [TaskDependencyUpsertWithWhereUniqueWithoutTaskInput!]
}

input TaskDependencyUpdateWithWhereUniqueWithoutDependsOnInput {
  data: TaskDependencyUpdateWithoutDependsOnInput!
  where: TaskDependencyWhereUniqueInput!
}

input TaskDependencyUpdateWithWhereUniqueWithoutTaskInput {
  data: TaskDependencyUpdateWithoutTaskInput!
  where: TaskDependencyWhereUniqueInput!
}

input TaskDependencyUpdateWithoutDependsOnInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  task: TaskUpdateOneRequiredWithoutDependenciesNestedInput
}

input TaskDependencyUpdateWithoutTaskInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  dependsOn: TaskUpdateOneRequiredWithoutDependentsNestedInput
}

input TaskDependencyUpsertWithWhereUniqueWithoutDependsOnInput {
  create: TaskDependencyCreateWithoutDependsOnInput!
  update: TaskDependencyUpdateWithoutDependsOnInput!
  where: TaskDependencyWhereUniqueInput!
}

input TaskDependencyUpsertWithWhereUniqueWithoutTaskInput {
  create: TaskDependencyCreateWithoutTaskInput!
  update: TaskDependencyUpdateWithoutTaskInput!
  where: TaskDependencyWhereUniqueInput!
}

input TaskDependencyWhereInput {
  AND: [TaskDependencyWhereInput!]
  NOT: [TaskDependencyWhereInput!]
  OR: [TaskDependencyWhereInput!]
  createdAt: DateTimeFilter
  dependsOn: TaskRelationFilter
  dependsOnId: IntFilter
  id: IntFilter
  task: TaskRelationFilter
  taskId: IntFilter
}

input TaskDependencyWhereUniqueInput {
  AND: [TaskDependencyWhereInput!]
  NOT: [TaskDependencyWhereInput!]
  OR: [TaskDependencyWhereInput!]
  createdAt: DateTimeFilter
  dependsOn: TaskRelationFilter
  dependsOnId: IntFilter
  id: Int
  task: TaskRelationFilter
  taskId: IntFilter
  taskId_dependsOnId: TaskDependencyTaskIdDependsOnIdCompoundUniqueInput
}

type TaskGroupBy {
  _avg: TaskAvgAggregate
  _count: TaskCountAggregate
  _max: TaskMaxAggregate
  _min: TaskMinAggregate
  _sum: TaskSumAggregate
  complexity: Int
  createdAt: DateTime!
  description: String!
  details: String
  id: Int!
  priority: String!
  status: String!
  testStrategy: String
  title: String!
  updatedAt: DateTime!
}

type TaskMasterMetadata {
  created: DateTime!
  description: String!
  id: Int!
  updated: DateTime!
}

type TaskMasterMetadataAvgAggregate {
  id: Float
}

input TaskMasterMetadataAvgOrderByAggregateInput {
  id: SortOrder
}

type TaskMasterMetadataCountAggregate {
  _all: Int!
  created: Int!
  description: Int!
  id: Int!
  updated: Int!
}

input TaskMasterMetadataCountOrderByAggregateInput {
  created: SortOrder
  description: SortOrder
  id: SortOrder
  updated: SortOrder
}

input TaskMasterMetadataCreateInput {
  created: DateTime!
  description: String!
  updated: DateTime!
}

input TaskMasterMetadataCreateManyInput {
  created: DateTime!
  description: String!
  id: Int
  updated: DateTime!
}

type TaskMasterMetadataGroupBy {
  _avg: TaskMasterMetadataAvgAggregate
  _count: TaskMasterMetadataCountAggregate
  _max: TaskMasterMetadataMaxAggregate
  _min: TaskMasterMetadataMinAggregate
  _sum: TaskMasterMetadataSumAggregate
  created: DateTime!
  description: String!
  id: Int!
  updated: DateTime!
}

type TaskMasterMetadataMaxAggregate {
  created: DateTime
  description: String
  id: Int
  updated: DateTime
}

input TaskMasterMetadataMaxOrderByAggregateInput {
  created: SortOrder
  description: SortOrder
  id: SortOrder
  updated: SortOrder
}

type TaskMasterMetadataMinAggregate {
  created: DateTime
  description: String
  id: Int
  updated: DateTime
}

input TaskMasterMetadataMinOrderByAggregateInput {
  created: SortOrder
  description: SortOrder
  id: SortOrder
  updated: SortOrder
}

input TaskMasterMetadataOrderByWithAggregationInput {
  _avg: TaskMasterMetadataAvgOrderByAggregateInput
  _count: TaskMasterMetadataCountOrderByAggregateInput
  _max: TaskMasterMetadataMaxOrderByAggregateInput
  _min: TaskMasterMetadataMinOrderByAggregateInput
  _sum: TaskMasterMetadataSumOrderByAggregateInput
  created: SortOrder
  description: SortOrder
  id: SortOrder
  updated: SortOrder
}

input TaskMasterMetadataOrderByWithRelationInput {
  created: SortOrder
  description: SortOrder
  id: SortOrder
  updated: SortOrder
}

enum TaskMasterMetadataScalarFieldEnum {
  created
  description
  id
  updated
}

input TaskMasterMetadataScalarWhereWithAggregatesInput {
  AND: [TaskMasterMetadataScalarWhereWithAggregatesInput!]
  NOT: [TaskMasterMetadataScalarWhereWithAggregatesInput!]
  OR: [TaskMasterMetadataScalarWhereWithAggregatesInput!]
  created: DateTimeWithAggregatesFilter
  description: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  updated: DateTimeWithAggregatesFilter
}

type TaskMasterMetadataSumAggregate {
  id: Int
}

input TaskMasterMetadataSumOrderByAggregateInput {
  id: SortOrder
}

input TaskMasterMetadataUpdateInput {
  created: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  updated: DateTimeFieldUpdateOperationsInput
}

input TaskMasterMetadataUpdateManyMutationInput {
  created: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  updated: DateTimeFieldUpdateOperationsInput
}

input TaskMasterMetadataWhereInput {
  AND: [TaskMasterMetadataWhereInput!]
  NOT: [TaskMasterMetadataWhereInput!]
  OR: [TaskMasterMetadataWhereInput!]
  created: DateTimeFilter
  description: StringFilter
  id: IntFilter
  updated: DateTimeFilter
}

input TaskMasterMetadataWhereUniqueInput {
  AND: [TaskMasterMetadataWhereInput!]
  NOT: [TaskMasterMetadataWhereInput!]
  OR: [TaskMasterMetadataWhereInput!]
  created: DateTimeFilter
  description: StringFilter
  id: Int
  updated: DateTimeFilter
}

type TaskMaxAggregate {
  complexity: Int
  createdAt: DateTime
  description: String
  details: String
  id: Int
  priority: String
  status: String
  testStrategy: String
  title: String
  updatedAt: DateTime
}

input TaskMaxOrderByAggregateInput {
  complexity: SortOrder
  createdAt: SortOrder
  description: SortOrder
  details: SortOrder
  id: SortOrder
  priority: SortOrder
  status: SortOrder
  testStrategy: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

type TaskMinAggregate {
  complexity: Int
  createdAt: DateTime
  description: String
  details: String
  id: Int
  priority: String
  status: String
  testStrategy: String
  title: String
  updatedAt: DateTime
}

input TaskMinOrderByAggregateInput {
  complexity: SortOrder
  createdAt: SortOrder
  description: SortOrder
  details: SortOrder
  id: SortOrder
  priority: SortOrder
  status: SortOrder
  testStrategy: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input TaskNullableRelationFilter {
  is: TaskWhereInput
  isNot: TaskWhereInput
}

input TaskOrderByWithAggregationInput {
  _avg: TaskAvgOrderByAggregateInput
  _count: TaskCountOrderByAggregateInput
  _max: TaskMaxOrderByAggregateInput
  _min: TaskMinOrderByAggregateInput
  _sum: TaskSumOrderByAggregateInput
  complexity: SortOrderInput
  createdAt: SortOrder
  description: SortOrder
  details: SortOrderInput
  id: SortOrder
  priority: SortOrder
  status: SortOrder
  testStrategy: SortOrderInput
  title: SortOrder
  updatedAt: SortOrder
}

input TaskOrderByWithRelationInput {
  complexity: SortOrderInput
  createdAt: SortOrder
  dependencies: TaskDependencyOrderByRelationAggregateInput
  dependents: TaskDependencyOrderByRelationAggregateInput
  description: SortOrder
  details: SortOrderInput
  id: SortOrder
  issues: IssueOrderByRelationAggregateInput
  priority: SortOrder
  status: SortOrder
  subtasks: SubtaskOrderByRelationAggregateInput
  testStrategy: SortOrderInput
  title: SortOrder
  updatedAt: SortOrder
}

input TaskRelationFilter {
  is: TaskWhereInput
  isNot: TaskWhereInput
}

enum TaskScalarFieldEnum {
  complexity
  createdAt
  description
  details
  id
  priority
  status
  testStrategy
  title
  updatedAt
}

input TaskScalarWhereWithAggregatesInput {
  AND: [TaskScalarWhereWithAggregatesInput!]
  NOT: [TaskScalarWhereWithAggregatesInput!]
  OR: [TaskScalarWhereWithAggregatesInput!]
  complexity: IntNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  description: StringWithAggregatesFilter
  details: StringNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  priority: StringWithAggregatesFilter
  status: StringWithAggregatesFilter
  testStrategy: StringNullableWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type TaskSumAggregate {
  complexity: Int
  id: Int
}

input TaskSumOrderByAggregateInput {
  complexity: SortOrder
  id: SortOrder
}

input TaskUpdateInput {
  complexity: NullableIntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  dependencies: TaskDependencyUpdateManyWithoutTaskNestedInput
  dependents: TaskDependencyUpdateManyWithoutDependsOnNestedInput
  description: StringFieldUpdateOperationsInput
  details: NullableStringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  issues: IssueUpdateManyWithoutTaskNestedInput
  priority: StringFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
  subtasks: SubtaskUpdateManyWithoutParentTaskNestedInput
  testStrategy: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TaskUpdateManyMutationInput {
  complexity: NullableIntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  details: NullableStringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  priority: StringFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
  testStrategy: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TaskUpdateOneRequiredWithoutDependenciesNestedInput {
  connect: TaskWhereUniqueInput
  connectOrCreate: TaskCreateOrConnectWithoutDependenciesInput
  create: TaskCreateWithoutDependenciesInput
  update: TaskUpdateToOneWithWhereWithoutDependenciesInput
  upsert: TaskUpsertWithoutDependenciesInput
}

input TaskUpdateOneRequiredWithoutDependentsNestedInput {
  connect: TaskWhereUniqueInput
  connectOrCreate: TaskCreateOrConnectWithoutDependentsInput
  create: TaskCreateWithoutDependentsInput
  update: TaskUpdateToOneWithWhereWithoutDependentsInput
  upsert: TaskUpsertWithoutDependentsInput
}

input TaskUpdateOneRequiredWithoutSubtasksNestedInput {
  connect: TaskWhereUniqueInput
  connectOrCreate: TaskCreateOrConnectWithoutSubtasksInput
  create: TaskCreateWithoutSubtasksInput
  update: TaskUpdateToOneWithWhereWithoutSubtasksInput
  upsert: TaskUpsertWithoutSubtasksInput
}

input TaskUpdateOneWithoutIssuesNestedInput {
  connect: TaskWhereUniqueInput
  connectOrCreate: TaskCreateOrConnectWithoutIssuesInput
  create: TaskCreateWithoutIssuesInput
  delete: TaskWhereInput
  disconnect: TaskWhereInput
  update: TaskUpdateToOneWithWhereWithoutIssuesInput
  upsert: TaskUpsertWithoutIssuesInput
}

input TaskUpdateToOneWithWhereWithoutDependenciesInput {
  data: TaskUpdateWithoutDependenciesInput!
  where: TaskWhereInput
}

input TaskUpdateToOneWithWhereWithoutDependentsInput {
  data: TaskUpdateWithoutDependentsInput!
  where: TaskWhereInput
}

input TaskUpdateToOneWithWhereWithoutIssuesInput {
  data: TaskUpdateWithoutIssuesInput!
  where: TaskWhereInput
}

input TaskUpdateToOneWithWhereWithoutSubtasksInput {
  data: TaskUpdateWithoutSubtasksInput!
  where: TaskWhereInput
}

input TaskUpdateWithoutDependenciesInput {
  complexity: NullableIntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  dependents: TaskDependencyUpdateManyWithoutDependsOnNestedInput
  description: StringFieldUpdateOperationsInput
  details: NullableStringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  issues: IssueUpdateManyWithoutTaskNestedInput
  priority: StringFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
  subtasks: SubtaskUpdateManyWithoutParentTaskNestedInput
  testStrategy: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TaskUpdateWithoutDependentsInput {
  complexity: NullableIntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  dependencies: TaskDependencyUpdateManyWithoutTaskNestedInput
  description: StringFieldUpdateOperationsInput
  details: NullableStringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  issues: IssueUpdateManyWithoutTaskNestedInput
  priority: StringFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
  subtasks: SubtaskUpdateManyWithoutParentTaskNestedInput
  testStrategy: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TaskUpdateWithoutIssuesInput {
  complexity: NullableIntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  dependencies: TaskDependencyUpdateManyWithoutTaskNestedInput
  dependents: TaskDependencyUpdateManyWithoutDependsOnNestedInput
  description: StringFieldUpdateOperationsInput
  details: NullableStringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  priority: StringFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
  subtasks: SubtaskUpdateManyWithoutParentTaskNestedInput
  testStrategy: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TaskUpdateWithoutSubtasksInput {
  complexity: NullableIntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  dependencies: TaskDependencyUpdateManyWithoutTaskNestedInput
  dependents: TaskDependencyUpdateManyWithoutDependsOnNestedInput
  description: StringFieldUpdateOperationsInput
  details: NullableStringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  issues: IssueUpdateManyWithoutTaskNestedInput
  priority: StringFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
  testStrategy: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TaskUpsertWithoutDependenciesInput {
  create: TaskCreateWithoutDependenciesInput!
  update: TaskUpdateWithoutDependenciesInput!
  where: TaskWhereInput
}

input TaskUpsertWithoutDependentsInput {
  create: TaskCreateWithoutDependentsInput!
  update: TaskUpdateWithoutDependentsInput!
  where: TaskWhereInput
}

input TaskUpsertWithoutIssuesInput {
  create: TaskCreateWithoutIssuesInput!
  update: TaskUpdateWithoutIssuesInput!
  where: TaskWhereInput
}

input TaskUpsertWithoutSubtasksInput {
  create: TaskCreateWithoutSubtasksInput!
  update: TaskUpdateWithoutSubtasksInput!
  where: TaskWhereInput
}

input TaskWhereInput {
  AND: [TaskWhereInput!]
  NOT: [TaskWhereInput!]
  OR: [TaskWhereInput!]
  complexity: IntNullableFilter
  createdAt: DateTimeFilter
  dependencies: TaskDependencyListRelationFilter
  dependents: TaskDependencyListRelationFilter
  description: StringFilter
  details: StringNullableFilter
  id: IntFilter
  issues: IssueListRelationFilter
  priority: StringFilter
  status: StringFilter
  subtasks: SubtaskListRelationFilter
  testStrategy: StringNullableFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input TaskWhereUniqueInput {
  AND: [TaskWhereInput!]
  NOT: [TaskWhereInput!]
  OR: [TaskWhereInput!]
  complexity: IntNullableFilter
  createdAt: DateTimeFilter
  dependencies: TaskDependencyListRelationFilter
  dependents: TaskDependencyListRelationFilter
  description: StringFilter
  details: StringNullableFilter
  id: Int
  issues: IssueListRelationFilter
  priority: StringFilter
  status: StringFilter
  subtasks: SubtaskListRelationFilter
  testStrategy: StringNullableFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

type Team {
  _count: TeamCount
  color: String!
  createdAt: DateTime!
  icon: String!
  id: String!
  joined: Boolean!
  name: String!
  updatedAt: DateTime!
}

type TeamCount {
  cycles(where: CycleWhereInput): Int!
  members(where: TeamMemberWhereInput): Int!
  projects(where: TeamProjectWhereInput): Int!
}

type TeamCountAggregate {
  _all: Int!
  color: Int!
  createdAt: Int!
  icon: Int!
  id: Int!
  joined: Int!
  name: Int!
  updatedAt: Int!
}

input TeamCountOrderByAggregateInput {
  color: SortOrder
  createdAt: SortOrder
  icon: SortOrder
  id: SortOrder
  joined: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input TeamCreateInput {
  color: String!
  createdAt: DateTime
  cycles: CycleCreateNestedManyWithoutTeamInput
  icon: String!
  id: String
  joined: Boolean
  members: TeamMemberCreateNestedManyWithoutTeamInput
  name: String!
  projects: TeamProjectCreateNestedManyWithoutTeamInput
  updatedAt: DateTime
}

input TeamCreateManyInput {
  color: String!
  createdAt: DateTime
  icon: String!
  id: String
  joined: Boolean
  name: String!
  updatedAt: DateTime
}

input TeamCreateNestedOneWithoutCyclesInput {
  connect: TeamWhereUniqueInput
  connectOrCreate: TeamCreateOrConnectWithoutCyclesInput
  create: TeamCreateWithoutCyclesInput
}

input TeamCreateNestedOneWithoutMembersInput {
  connect: TeamWhereUniqueInput
  connectOrCreate: TeamCreateOrConnectWithoutMembersInput
  create: TeamCreateWithoutMembersInput
}

input TeamCreateNestedOneWithoutProjectsInput {
  connect: TeamWhereUniqueInput
  connectOrCreate: TeamCreateOrConnectWithoutProjectsInput
  create: TeamCreateWithoutProjectsInput
}

input TeamCreateOrConnectWithoutCyclesInput {
  create: TeamCreateWithoutCyclesInput!
  where: TeamWhereUniqueInput!
}

input TeamCreateOrConnectWithoutMembersInput {
  create: TeamCreateWithoutMembersInput!
  where: TeamWhereUniqueInput!
}

input TeamCreateOrConnectWithoutProjectsInput {
  create: TeamCreateWithoutProjectsInput!
  where: TeamWhereUniqueInput!
}

input TeamCreateWithoutCyclesInput {
  color: String!
  createdAt: DateTime
  icon: String!
  id: String
  joined: Boolean
  members: TeamMemberCreateNestedManyWithoutTeamInput
  name: String!
  projects: TeamProjectCreateNestedManyWithoutTeamInput
  updatedAt: DateTime
}

input TeamCreateWithoutMembersInput {
  color: String!
  createdAt: DateTime
  cycles: CycleCreateNestedManyWithoutTeamInput
  icon: String!
  id: String
  joined: Boolean
  name: String!
  projects: TeamProjectCreateNestedManyWithoutTeamInput
  updatedAt: DateTime
}

input TeamCreateWithoutProjectsInput {
  color: String!
  createdAt: DateTime
  cycles: CycleCreateNestedManyWithoutTeamInput
  icon: String!
  id: String
  joined: Boolean
  members: TeamMemberCreateNestedManyWithoutTeamInput
  name: String!
  updatedAt: DateTime
}

type TeamGroupBy {
  _count: TeamCountAggregate
  _max: TeamMaxAggregate
  _min: TeamMinAggregate
  color: String!
  createdAt: DateTime!
  icon: String!
  id: String!
  joined: Boolean!
  name: String!
  updatedAt: DateTime!
}

type TeamMaxAggregate {
  color: String
  createdAt: DateTime
  icon: String
  id: String
  joined: Boolean
  name: String
  updatedAt: DateTime
}

input TeamMaxOrderByAggregateInput {
  color: SortOrder
  createdAt: SortOrder
  icon: SortOrder
  id: SortOrder
  joined: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

type TeamMember {
  id: String!
  teamId: String!
  userId: String!
}

type TeamMemberCountAggregate {
  _all: Int!
  id: Int!
  teamId: Int!
  userId: Int!
}

input TeamMemberCountOrderByAggregateInput {
  id: SortOrder
  teamId: SortOrder
  userId: SortOrder
}

input TeamMemberCreateInput {
  id: String
  team: TeamCreateNestedOneWithoutMembersInput!
  user: UserCreateNestedOneWithoutTeamsInput!
}

input TeamMemberCreateManyInput {
  id: String
  teamId: String!
  userId: String!
}

input TeamMemberCreateManyTeamInput {
  id: String
  userId: String!
}

input TeamMemberCreateManyTeamInputEnvelope {
  data: [TeamMemberCreateManyTeamInput!]!
}

input TeamMemberCreateManyUserInput {
  id: String
  teamId: String!
}

input TeamMemberCreateManyUserInputEnvelope {
  data: [TeamMemberCreateManyUserInput!]!
}

input TeamMemberCreateNestedManyWithoutTeamInput {
  connect: [TeamMemberWhereUniqueInput!]
  connectOrCreate: [TeamMemberCreateOrConnectWithoutTeamInput!]
  create: [TeamMemberCreateWithoutTeamInput!]
  createMany: TeamMemberCreateManyTeamInputEnvelope
}

input TeamMemberCreateNestedManyWithoutUserInput {
  connect: [TeamMemberWhereUniqueInput!]
  connectOrCreate: [TeamMemberCreateOrConnectWithoutUserInput!]
  create: [TeamMemberCreateWithoutUserInput!]
  createMany: TeamMemberCreateManyUserInputEnvelope
}

input TeamMemberCreateOrConnectWithoutTeamInput {
  create: TeamMemberCreateWithoutTeamInput!
  where: TeamMemberWhereUniqueInput!
}

input TeamMemberCreateOrConnectWithoutUserInput {
  create: TeamMemberCreateWithoutUserInput!
  where: TeamMemberWhereUniqueInput!
}

input TeamMemberCreateWithoutTeamInput {
  id: String
  user: UserCreateNestedOneWithoutTeamsInput!
}

input TeamMemberCreateWithoutUserInput {
  id: String
  team: TeamCreateNestedOneWithoutMembersInput!
}

type TeamMemberGroupBy {
  _count: TeamMemberCountAggregate
  _max: TeamMemberMaxAggregate
  _min: TeamMemberMinAggregate
  id: String!
  teamId: String!
  userId: String!
}

input TeamMemberListRelationFilter {
  every: TeamMemberWhereInput
  none: TeamMemberWhereInput
  some: TeamMemberWhereInput
}

type TeamMemberMaxAggregate {
  id: String
  teamId: String
  userId: String
}

input TeamMemberMaxOrderByAggregateInput {
  id: SortOrder
  teamId: SortOrder
  userId: SortOrder
}

type TeamMemberMinAggregate {
  id: String
  teamId: String
  userId: String
}

input TeamMemberMinOrderByAggregateInput {
  id: SortOrder
  teamId: SortOrder
  userId: SortOrder
}

input TeamMemberOrderByRelationAggregateInput {
  _count: SortOrder
}

input TeamMemberOrderByWithAggregationInput {
  _count: TeamMemberCountOrderByAggregateInput
  _max: TeamMemberMaxOrderByAggregateInput
  _min: TeamMemberMinOrderByAggregateInput
  id: SortOrder
  teamId: SortOrder
  userId: SortOrder
}

input TeamMemberOrderByWithRelationInput {
  id: SortOrder
  team: TeamOrderByWithRelationInput
  teamId: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum TeamMemberScalarFieldEnum {
  id
  teamId
  userId
}

input TeamMemberScalarWhereInput {
  AND: [TeamMemberScalarWhereInput!]
  NOT: [TeamMemberScalarWhereInput!]
  OR: [TeamMemberScalarWhereInput!]
  id: StringFilter
  teamId: StringFilter
  userId: StringFilter
}

input TeamMemberScalarWhereWithAggregatesInput {
  AND: [TeamMemberScalarWhereWithAggregatesInput!]
  NOT: [TeamMemberScalarWhereWithAggregatesInput!]
  OR: [TeamMemberScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  teamId: StringWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

input TeamMemberTeamIdUserIdCompoundUniqueInput {
  teamId: String!
  userId: String!
}

input TeamMemberUpdateInput {
  id: StringFieldUpdateOperationsInput
  team: TeamUpdateOneRequiredWithoutMembersNestedInput
  user: UserUpdateOneRequiredWithoutTeamsNestedInput
}

input TeamMemberUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
}

input TeamMemberUpdateManyWithWhereWithoutTeamInput {
  data: TeamMemberUpdateManyMutationInput!
  where: TeamMemberScalarWhereInput!
}

input TeamMemberUpdateManyWithWhereWithoutUserInput {
  data: TeamMemberUpdateManyMutationInput!
  where: TeamMemberScalarWhereInput!
}

input TeamMemberUpdateManyWithoutTeamNestedInput {
  connect: [TeamMemberWhereUniqueInput!]
  connectOrCreate: [TeamMemberCreateOrConnectWithoutTeamInput!]
  create: [TeamMemberCreateWithoutTeamInput!]
  createMany: TeamMemberCreateManyTeamInputEnvelope
  delete: [TeamMemberWhereUniqueInput!]
  deleteMany: [TeamMemberScalarWhereInput!]
  disconnect: [TeamMemberWhereUniqueInput!]
  set: [TeamMemberWhereUniqueInput!]
  update: [TeamMemberUpdateWithWhereUniqueWithoutTeamInput!]
  updateMany: [TeamMemberUpdateManyWithWhereWithoutTeamInput!]
  upsert: [TeamMemberUpsertWithWhereUniqueWithoutTeamInput!]
}

input TeamMemberUpdateManyWithoutUserNestedInput {
  connect: [TeamMemberWhereUniqueInput!]
  connectOrCreate: [TeamMemberCreateOrConnectWithoutUserInput!]
  create: [TeamMemberCreateWithoutUserInput!]
  createMany: TeamMemberCreateManyUserInputEnvelope
  delete: [TeamMemberWhereUniqueInput!]
  deleteMany: [TeamMemberScalarWhereInput!]
  disconnect: [TeamMemberWhereUniqueInput!]
  set: [TeamMemberWhereUniqueInput!]
  update: [TeamMemberUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [TeamMemberUpdateManyWithWhereWithoutUserInput!]
  upsert: [TeamMemberUpsertWithWhereUniqueWithoutUserInput!]
}

input TeamMemberUpdateWithWhereUniqueWithoutTeamInput {
  data: TeamMemberUpdateWithoutTeamInput!
  where: TeamMemberWhereUniqueInput!
}

input TeamMemberUpdateWithWhereUniqueWithoutUserInput {
  data: TeamMemberUpdateWithoutUserInput!
  where: TeamMemberWhereUniqueInput!
}

input TeamMemberUpdateWithoutTeamInput {
  id: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutTeamsNestedInput
}

input TeamMemberUpdateWithoutUserInput {
  id: StringFieldUpdateOperationsInput
  team: TeamUpdateOneRequiredWithoutMembersNestedInput
}

input TeamMemberUpsertWithWhereUniqueWithoutTeamInput {
  create: TeamMemberCreateWithoutTeamInput!
  update: TeamMemberUpdateWithoutTeamInput!
  where: TeamMemberWhereUniqueInput!
}

input TeamMemberUpsertWithWhereUniqueWithoutUserInput {
  create: TeamMemberCreateWithoutUserInput!
  update: TeamMemberUpdateWithoutUserInput!
  where: TeamMemberWhereUniqueInput!
}

input TeamMemberWhereInput {
  AND: [TeamMemberWhereInput!]
  NOT: [TeamMemberWhereInput!]
  OR: [TeamMemberWhereInput!]
  id: StringFilter
  team: TeamRelationFilter
  teamId: StringFilter
  user: UserRelationFilter
  userId: StringFilter
}

input TeamMemberWhereUniqueInput {
  AND: [TeamMemberWhereInput!]
  NOT: [TeamMemberWhereInput!]
  OR: [TeamMemberWhereInput!]
  id: String
  team: TeamRelationFilter
  teamId: StringFilter
  teamId_userId: TeamMemberTeamIdUserIdCompoundUniqueInput
  user: UserRelationFilter
  userId: StringFilter
}

type TeamMinAggregate {
  color: String
  createdAt: DateTime
  icon: String
  id: String
  joined: Boolean
  name: String
  updatedAt: DateTime
}

input TeamMinOrderByAggregateInput {
  color: SortOrder
  createdAt: SortOrder
  icon: SortOrder
  id: SortOrder
  joined: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input TeamOrderByWithAggregationInput {
  _count: TeamCountOrderByAggregateInput
  _max: TeamMaxOrderByAggregateInput
  _min: TeamMinOrderByAggregateInput
  color: SortOrder
  createdAt: SortOrder
  icon: SortOrder
  id: SortOrder
  joined: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input TeamOrderByWithRelationInput {
  color: SortOrder
  createdAt: SortOrder
  cycles: CycleOrderByRelationAggregateInput
  icon: SortOrder
  id: SortOrder
  joined: SortOrder
  members: TeamMemberOrderByRelationAggregateInput
  name: SortOrder
  projects: TeamProjectOrderByRelationAggregateInput
  updatedAt: SortOrder
}

type TeamProject {
  id: String!
  projectId: String!
  teamId: String!
}

type TeamProjectCountAggregate {
  _all: Int!
  id: Int!
  projectId: Int!
  teamId: Int!
}

input TeamProjectCountOrderByAggregateInput {
  id: SortOrder
  projectId: SortOrder
  teamId: SortOrder
}

input TeamProjectCreateInput {
  id: String
  project: ProjectCreateNestedOneWithoutTeamsInput!
  team: TeamCreateNestedOneWithoutProjectsInput!
}

input TeamProjectCreateManyInput {
  id: String
  projectId: String!
  teamId: String!
}

input TeamProjectCreateManyProjectInput {
  id: String
  teamId: String!
}

input TeamProjectCreateManyProjectInputEnvelope {
  data: [TeamProjectCreateManyProjectInput!]!
}

input TeamProjectCreateManyTeamInput {
  id: String
  projectId: String!
}

input TeamProjectCreateManyTeamInputEnvelope {
  data: [TeamProjectCreateManyTeamInput!]!
}

input TeamProjectCreateNestedManyWithoutProjectInput {
  connect: [TeamProjectWhereUniqueInput!]
  connectOrCreate: [TeamProjectCreateOrConnectWithoutProjectInput!]
  create: [TeamProjectCreateWithoutProjectInput!]
  createMany: TeamProjectCreateManyProjectInputEnvelope
}

input TeamProjectCreateNestedManyWithoutTeamInput {
  connect: [TeamProjectWhereUniqueInput!]
  connectOrCreate: [TeamProjectCreateOrConnectWithoutTeamInput!]
  create: [TeamProjectCreateWithoutTeamInput!]
  createMany: TeamProjectCreateManyTeamInputEnvelope
}

input TeamProjectCreateOrConnectWithoutProjectInput {
  create: TeamProjectCreateWithoutProjectInput!
  where: TeamProjectWhereUniqueInput!
}

input TeamProjectCreateOrConnectWithoutTeamInput {
  create: TeamProjectCreateWithoutTeamInput!
  where: TeamProjectWhereUniqueInput!
}

input TeamProjectCreateWithoutProjectInput {
  id: String
  team: TeamCreateNestedOneWithoutProjectsInput!
}

input TeamProjectCreateWithoutTeamInput {
  id: String
  project: ProjectCreateNestedOneWithoutTeamsInput!
}

type TeamProjectGroupBy {
  _count: TeamProjectCountAggregate
  _max: TeamProjectMaxAggregate
  _min: TeamProjectMinAggregate
  id: String!
  projectId: String!
  teamId: String!
}

input TeamProjectListRelationFilter {
  every: TeamProjectWhereInput
  none: TeamProjectWhereInput
  some: TeamProjectWhereInput
}

type TeamProjectMaxAggregate {
  id: String
  projectId: String
  teamId: String
}

input TeamProjectMaxOrderByAggregateInput {
  id: SortOrder
  projectId: SortOrder
  teamId: SortOrder
}

type TeamProjectMinAggregate {
  id: String
  projectId: String
  teamId: String
}

input TeamProjectMinOrderByAggregateInput {
  id: SortOrder
  projectId: SortOrder
  teamId: SortOrder
}

input TeamProjectOrderByRelationAggregateInput {
  _count: SortOrder
}

input TeamProjectOrderByWithAggregationInput {
  _count: TeamProjectCountOrderByAggregateInput
  _max: TeamProjectMaxOrderByAggregateInput
  _min: TeamProjectMinOrderByAggregateInput
  id: SortOrder
  projectId: SortOrder
  teamId: SortOrder
}

input TeamProjectOrderByWithRelationInput {
  id: SortOrder
  project: ProjectOrderByWithRelationInput
  projectId: SortOrder
  team: TeamOrderByWithRelationInput
  teamId: SortOrder
}

enum TeamProjectScalarFieldEnum {
  id
  projectId
  teamId
}

input TeamProjectScalarWhereInput {
  AND: [TeamProjectScalarWhereInput!]
  NOT: [TeamProjectScalarWhereInput!]
  OR: [TeamProjectScalarWhereInput!]
  id: StringFilter
  projectId: StringFilter
  teamId: StringFilter
}

input TeamProjectScalarWhereWithAggregatesInput {
  AND: [TeamProjectScalarWhereWithAggregatesInput!]
  NOT: [TeamProjectScalarWhereWithAggregatesInput!]
  OR: [TeamProjectScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  projectId: StringWithAggregatesFilter
  teamId: StringWithAggregatesFilter
}

input TeamProjectTeamIdProjectIdCompoundUniqueInput {
  projectId: String!
  teamId: String!
}

input TeamProjectUpdateInput {
  id: StringFieldUpdateOperationsInput
  project: ProjectUpdateOneRequiredWithoutTeamsNestedInput
  team: TeamUpdateOneRequiredWithoutProjectsNestedInput
}

input TeamProjectUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
}

input TeamProjectUpdateManyWithWhereWithoutProjectInput {
  data: TeamProjectUpdateManyMutationInput!
  where: TeamProjectScalarWhereInput!
}

input TeamProjectUpdateManyWithWhereWithoutTeamInput {
  data: TeamProjectUpdateManyMutationInput!
  where: TeamProjectScalarWhereInput!
}

input TeamProjectUpdateManyWithoutProjectNestedInput {
  connect: [TeamProjectWhereUniqueInput!]
  connectOrCreate: [TeamProjectCreateOrConnectWithoutProjectInput!]
  create: [TeamProjectCreateWithoutProjectInput!]
  createMany: TeamProjectCreateManyProjectInputEnvelope
  delete: [TeamProjectWhereUniqueInput!]
  deleteMany: [TeamProjectScalarWhereInput!]
  disconnect: [TeamProjectWhereUniqueInput!]
  set: [TeamProjectWhereUniqueInput!]
  update: [TeamProjectUpdateWithWhereUniqueWithoutProjectInput!]
  updateMany: [TeamProjectUpdateManyWithWhereWithoutProjectInput!]
  upsert: [TeamProjectUpsertWithWhereUniqueWithoutProjectInput!]
}

input TeamProjectUpdateManyWithoutTeamNestedInput {
  connect: [TeamProjectWhereUniqueInput!]
  connectOrCreate: [TeamProjectCreateOrConnectWithoutTeamInput!]
  create: [TeamProjectCreateWithoutTeamInput!]
  createMany: TeamProjectCreateManyTeamInputEnvelope
  delete: [TeamProjectWhereUniqueInput!]
  deleteMany: [TeamProjectScalarWhereInput!]
  disconnect: [TeamProjectWhereUniqueInput!]
  set: [TeamProjectWhereUniqueInput!]
  update: [TeamProjectUpdateWithWhereUniqueWithoutTeamInput!]
  updateMany: [TeamProjectUpdateManyWithWhereWithoutTeamInput!]
  upsert: [TeamProjectUpsertWithWhereUniqueWithoutTeamInput!]
}

input TeamProjectUpdateWithWhereUniqueWithoutProjectInput {
  data: TeamProjectUpdateWithoutProjectInput!
  where: TeamProjectWhereUniqueInput!
}

input TeamProjectUpdateWithWhereUniqueWithoutTeamInput {
  data: TeamProjectUpdateWithoutTeamInput!
  where: TeamProjectWhereUniqueInput!
}

input TeamProjectUpdateWithoutProjectInput {
  id: StringFieldUpdateOperationsInput
  team: TeamUpdateOneRequiredWithoutProjectsNestedInput
}

input TeamProjectUpdateWithoutTeamInput {
  id: StringFieldUpdateOperationsInput
  project: ProjectUpdateOneRequiredWithoutTeamsNestedInput
}

input TeamProjectUpsertWithWhereUniqueWithoutProjectInput {
  create: TeamProjectCreateWithoutProjectInput!
  update: TeamProjectUpdateWithoutProjectInput!
  where: TeamProjectWhereUniqueInput!
}

input TeamProjectUpsertWithWhereUniqueWithoutTeamInput {
  create: TeamProjectCreateWithoutTeamInput!
  update: TeamProjectUpdateWithoutTeamInput!
  where: TeamProjectWhereUniqueInput!
}

input TeamProjectWhereInput {
  AND: [TeamProjectWhereInput!]
  NOT: [TeamProjectWhereInput!]
  OR: [TeamProjectWhereInput!]
  id: StringFilter
  project: ProjectRelationFilter
  projectId: StringFilter
  team: TeamRelationFilter
  teamId: StringFilter
}

input TeamProjectWhereUniqueInput {
  AND: [TeamProjectWhereInput!]
  NOT: [TeamProjectWhereInput!]
  OR: [TeamProjectWhereInput!]
  id: String
  project: ProjectRelationFilter
  projectId: StringFilter
  team: TeamRelationFilter
  teamId: StringFilter
  teamId_projectId: TeamProjectTeamIdProjectIdCompoundUniqueInput
}

input TeamRelationFilter {
  is: TeamWhereInput
  isNot: TeamWhereInput
}

enum TeamScalarFieldEnum {
  color
  createdAt
  icon
  id
  joined
  name
  updatedAt
}

input TeamScalarWhereWithAggregatesInput {
  AND: [TeamScalarWhereWithAggregatesInput!]
  NOT: [TeamScalarWhereWithAggregatesInput!]
  OR: [TeamScalarWhereWithAggregatesInput!]
  color: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  icon: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  joined: BoolWithAggregatesFilter
  name: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input TeamUpdateInput {
  color: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  cycles: CycleUpdateManyWithoutTeamNestedInput
  icon: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  joined: BoolFieldUpdateOperationsInput
  members: TeamMemberUpdateManyWithoutTeamNestedInput
  name: StringFieldUpdateOperationsInput
  projects: TeamProjectUpdateManyWithoutTeamNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TeamUpdateManyMutationInput {
  color: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  icon: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  joined: BoolFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TeamUpdateOneRequiredWithoutCyclesNestedInput {
  connect: TeamWhereUniqueInput
  connectOrCreate: TeamCreateOrConnectWithoutCyclesInput
  create: TeamCreateWithoutCyclesInput
  update: TeamUpdateToOneWithWhereWithoutCyclesInput
  upsert: TeamUpsertWithoutCyclesInput
}

input TeamUpdateOneRequiredWithoutMembersNestedInput {
  connect: TeamWhereUniqueInput
  connectOrCreate: TeamCreateOrConnectWithoutMembersInput
  create: TeamCreateWithoutMembersInput
  update: TeamUpdateToOneWithWhereWithoutMembersInput
  upsert: TeamUpsertWithoutMembersInput
}

input TeamUpdateOneRequiredWithoutProjectsNestedInput {
  connect: TeamWhereUniqueInput
  connectOrCreate: TeamCreateOrConnectWithoutProjectsInput
  create: TeamCreateWithoutProjectsInput
  update: TeamUpdateToOneWithWhereWithoutProjectsInput
  upsert: TeamUpsertWithoutProjectsInput
}

input TeamUpdateToOneWithWhereWithoutCyclesInput {
  data: TeamUpdateWithoutCyclesInput!
  where: TeamWhereInput
}

input TeamUpdateToOneWithWhereWithoutMembersInput {
  data: TeamUpdateWithoutMembersInput!
  where: TeamWhereInput
}

input TeamUpdateToOneWithWhereWithoutProjectsInput {
  data: TeamUpdateWithoutProjectsInput!
  where: TeamWhereInput
}

input TeamUpdateWithoutCyclesInput {
  color: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  icon: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  joined: BoolFieldUpdateOperationsInput
  members: TeamMemberUpdateManyWithoutTeamNestedInput
  name: StringFieldUpdateOperationsInput
  projects: TeamProjectUpdateManyWithoutTeamNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TeamUpdateWithoutMembersInput {
  color: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  cycles: CycleUpdateManyWithoutTeamNestedInput
  icon: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  joined: BoolFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  projects: TeamProjectUpdateManyWithoutTeamNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TeamUpdateWithoutProjectsInput {
  color: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  cycles: CycleUpdateManyWithoutTeamNestedInput
  icon: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  joined: BoolFieldUpdateOperationsInput
  members: TeamMemberUpdateManyWithoutTeamNestedInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TeamUpsertWithoutCyclesInput {
  create: TeamCreateWithoutCyclesInput!
  update: TeamUpdateWithoutCyclesInput!
  where: TeamWhereInput
}

input TeamUpsertWithoutMembersInput {
  create: TeamCreateWithoutMembersInput!
  update: TeamUpdateWithoutMembersInput!
  where: TeamWhereInput
}

input TeamUpsertWithoutProjectsInput {
  create: TeamCreateWithoutProjectsInput!
  update: TeamUpdateWithoutProjectsInput!
  where: TeamWhereInput
}

input TeamWhereInput {
  AND: [TeamWhereInput!]
  NOT: [TeamWhereInput!]
  OR: [TeamWhereInput!]
  color: StringFilter
  createdAt: DateTimeFilter
  cycles: CycleListRelationFilter
  icon: StringFilter
  id: StringFilter
  joined: BoolFilter
  members: TeamMemberListRelationFilter
  name: StringFilter
  projects: TeamProjectListRelationFilter
  updatedAt: DateTimeFilter
}

input TeamWhereUniqueInput {
  AND: [TeamWhereInput!]
  NOT: [TeamWhereInput!]
  OR: [TeamWhereInput!]
  color: StringFilter
  createdAt: DateTimeFilter
  cycles: CycleListRelationFilter
  icon: StringFilter
  id: String
  joined: BoolFilter
  members: TeamMemberListRelationFilter
  name: StringFilter
  projects: TeamProjectListRelationFilter
  updatedAt: DateTimeFilter
}

type User {
  _count: UserCount
  avatarUrl: String
  createdAt: DateTime!
  email: String!
  id: String!
  joinedDate: DateTime!
  name: String!
  role: String!
  status: String!
  teamIds: String!
  updatedAt: DateTime!
}

type UserCount {
  assignedIssues(where: IssueWhereInput): Int!
  ledProjects(where: ProjectWhereInput): Int!
  teams(where: TeamMemberWhereInput): Int!
}

type UserCountAggregate {
  _all: Int!
  avatarUrl: Int!
  createdAt: Int!
  email: Int!
  id: Int!
  joinedDate: Int!
  name: Int!
  role: Int!
  status: Int!
  teamIds: Int!
  updatedAt: Int!
}

input UserCountOrderByAggregateInput {
  avatarUrl: SortOrder
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  joinedDate: SortOrder
  name: SortOrder
  role: SortOrder
  status: SortOrder
  teamIds: SortOrder
  updatedAt: SortOrder
}

input UserCreateInput {
  assignedIssues: IssueCreateNestedManyWithoutAssigneeInput
  avatarUrl: String
  createdAt: DateTime
  email: String!
  id: String
  joinedDate: DateTime!
  ledProjects: ProjectCreateNestedManyWithoutLeadInput
  name: String!
  role: String
  status: String
  teamIds: String
  teams: TeamMemberCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateManyInput {
  avatarUrl: String
  createdAt: DateTime
  email: String!
  id: String
  joinedDate: DateTime!
  name: String!
  role: String
  status: String
  teamIds: String
  updatedAt: DateTime
}

input UserCreateNestedOneWithoutAssignedIssuesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutAssignedIssuesInput
  create: UserCreateWithoutAssignedIssuesInput
}

input UserCreateNestedOneWithoutLedProjectsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutLedProjectsInput
  create: UserCreateWithoutLedProjectsInput
}

input UserCreateNestedOneWithoutTeamsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutTeamsInput
  create: UserCreateWithoutTeamsInput
}

input UserCreateOrConnectWithoutAssignedIssuesInput {
  create: UserCreateWithoutAssignedIssuesInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutLedProjectsInput {
  create: UserCreateWithoutLedProjectsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutTeamsInput {
  create: UserCreateWithoutTeamsInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutAssignedIssuesInput {
  avatarUrl: String
  createdAt: DateTime
  email: String!
  id: String
  joinedDate: DateTime!
  ledProjects: ProjectCreateNestedManyWithoutLeadInput
  name: String!
  role: String
  status: String
  teamIds: String
  teams: TeamMemberCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateWithoutLedProjectsInput {
  assignedIssues: IssueCreateNestedManyWithoutAssigneeInput
  avatarUrl: String
  createdAt: DateTime
  email: String!
  id: String
  joinedDate: DateTime!
  name: String!
  role: String
  status: String
  teamIds: String
  teams: TeamMemberCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateWithoutTeamsInput {
  assignedIssues: IssueCreateNestedManyWithoutAssigneeInput
  avatarUrl: String
  createdAt: DateTime
  email: String!
  id: String
  joinedDate: DateTime!
  ledProjects: ProjectCreateNestedManyWithoutLeadInput
  name: String!
  role: String
  status: String
  teamIds: String
  updatedAt: DateTime
}

type UserGroupBy {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  avatarUrl: String
  createdAt: DateTime!
  email: String!
  id: String!
  joinedDate: DateTime!
  name: String!
  role: String!
  status: String!
  teamIds: String!
  updatedAt: DateTime!
}

type UserMaxAggregate {
  avatarUrl: String
  createdAt: DateTime
  email: String
  id: String
  joinedDate: DateTime
  name: String
  role: String
  status: String
  teamIds: String
  updatedAt: DateTime
}

input UserMaxOrderByAggregateInput {
  avatarUrl: SortOrder
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  joinedDate: SortOrder
  name: SortOrder
  role: SortOrder
  status: SortOrder
  teamIds: SortOrder
  updatedAt: SortOrder
}

type UserMinAggregate {
  avatarUrl: String
  createdAt: DateTime
  email: String
  id: String
  joinedDate: DateTime
  name: String
  role: String
  status: String
  teamIds: String
  updatedAt: DateTime
}

input UserMinOrderByAggregateInput {
  avatarUrl: SortOrder
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  joinedDate: SortOrder
  name: SortOrder
  role: SortOrder
  status: SortOrder
  teamIds: SortOrder
  updatedAt: SortOrder
}

input UserNullableRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserOrderByWithAggregationInput {
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  avatarUrl: SortOrderInput
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  joinedDate: SortOrder
  name: SortOrder
  role: SortOrder
  status: SortOrder
  teamIds: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithRelationInput {
  assignedIssues: IssueOrderByRelationAggregateInput
  avatarUrl: SortOrderInput
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  joinedDate: SortOrder
  ledProjects: ProjectOrderByRelationAggregateInput
  name: SortOrder
  role: SortOrder
  status: SortOrder
  teamIds: SortOrder
  teams: TeamMemberOrderByRelationAggregateInput
  updatedAt: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  avatarUrl
  createdAt
  email
  id
  joinedDate
  name
  role
  status
  teamIds
  updatedAt
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  avatarUrl: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  joinedDate: DateTimeWithAggregatesFilter
  name: StringWithAggregatesFilter
  role: StringWithAggregatesFilter
  status: StringWithAggregatesFilter
  teamIds: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input UserUpdateInput {
  assignedIssues: IssueUpdateManyWithoutAssigneeNestedInput
  avatarUrl: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  joinedDate: DateTimeFieldUpdateOperationsInput
  ledProjects: ProjectUpdateManyWithoutLeadNestedInput
  name: StringFieldUpdateOperationsInput
  role: StringFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
  teamIds: StringFieldUpdateOperationsInput
  teams: TeamMemberUpdateManyWithoutUserNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  avatarUrl: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  joinedDate: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  role: StringFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
  teamIds: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutTeamsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutTeamsInput
  create: UserCreateWithoutTeamsInput
  update: UserUpdateToOneWithWhereWithoutTeamsInput
  upsert: UserUpsertWithoutTeamsInput
}

input UserUpdateOneWithoutAssignedIssuesNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutAssignedIssuesInput
  create: UserCreateWithoutAssignedIssuesInput
  delete: UserWhereInput
  disconnect: UserWhereInput
  update: UserUpdateToOneWithWhereWithoutAssignedIssuesInput
  upsert: UserUpsertWithoutAssignedIssuesInput
}

input UserUpdateOneWithoutLedProjectsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutLedProjectsInput
  create: UserCreateWithoutLedProjectsInput
  delete: UserWhereInput
  disconnect: UserWhereInput
  update: UserUpdateToOneWithWhereWithoutLedProjectsInput
  upsert: UserUpsertWithoutLedProjectsInput
}

input UserUpdateToOneWithWhereWithoutAssignedIssuesInput {
  data: UserUpdateWithoutAssignedIssuesInput!
  where: UserWhereInput
}

input UserUpdateToOneWithWhereWithoutLedProjectsInput {
  data: UserUpdateWithoutLedProjectsInput!
  where: UserWhereInput
}

input UserUpdateToOneWithWhereWithoutTeamsInput {
  data: UserUpdateWithoutTeamsInput!
  where: UserWhereInput
}

input UserUpdateWithoutAssignedIssuesInput {
  avatarUrl: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  joinedDate: DateTimeFieldUpdateOperationsInput
  ledProjects: ProjectUpdateManyWithoutLeadNestedInput
  name: StringFieldUpdateOperationsInput
  role: StringFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
  teamIds: StringFieldUpdateOperationsInput
  teams: TeamMemberUpdateManyWithoutUserNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutLedProjectsInput {
  assignedIssues: IssueUpdateManyWithoutAssigneeNestedInput
  avatarUrl: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  joinedDate: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  role: StringFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
  teamIds: StringFieldUpdateOperationsInput
  teams: TeamMemberUpdateManyWithoutUserNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutTeamsInput {
  assignedIssues: IssueUpdateManyWithoutAssigneeNestedInput
  avatarUrl: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  joinedDate: DateTimeFieldUpdateOperationsInput
  ledProjects: ProjectUpdateManyWithoutLeadNestedInput
  name: StringFieldUpdateOperationsInput
  role: StringFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
  teamIds: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpsertWithoutAssignedIssuesInput {
  create: UserCreateWithoutAssignedIssuesInput!
  update: UserUpdateWithoutAssignedIssuesInput!
  where: UserWhereInput
}

input UserUpsertWithoutLedProjectsInput {
  create: UserCreateWithoutLedProjectsInput!
  update: UserUpdateWithoutLedProjectsInput!
  where: UserWhereInput
}

input UserUpsertWithoutTeamsInput {
  create: UserCreateWithoutTeamsInput!
  update: UserUpdateWithoutTeamsInput!
  where: UserWhereInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  assignedIssues: IssueListRelationFilter
  avatarUrl: StringNullableFilter
  createdAt: DateTimeFilter
  email: StringFilter
  id: StringFilter
  joinedDate: DateTimeFilter
  ledProjects: ProjectListRelationFilter
  name: StringFilter
  role: StringFilter
  status: StringFilter
  teamIds: StringFilter
  teams: TeamMemberListRelationFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  assignedIssues: IssueListRelationFilter
  avatarUrl: StringNullableFilter
  createdAt: DateTimeFilter
  email: String
  id: String
  joinedDate: DateTimeFilter
  ledProjects: ProjectListRelationFilter
  name: StringFilter
  role: StringFilter
  status: StringFilter
  teamIds: StringFilter
  teams: TeamMemberListRelationFilter
  updatedAt: DateTimeFilter
}