// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

generator typegraphql {
  provider = "typegraphql-prisma"
  output   = "../libs/server/graphql/generated"
  emitTranspiledCode = true
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// Main Task model matching Task Master structure
model Task {
  id           Int     @id
  title        String
  description  String
  details      String?
  testStrategy String?
  priority     String  // 'high', 'medium', 'low'
  status       String  // 'pending', 'in-progress', 'done', 'deferred', 'cancelled', 'blocked'
  complexity   Int?
  
  // Relationships
  subtasks     Subtask[]
  dependencies TaskDependency[] @relation("TaskToDependencies")
  dependents   TaskDependency[] @relation("DependencyToTasks")
  issues       Issue[]
  
  // Timestamps
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@map("tasks")
}

// Subtask model for nested task structure
model Subtask {
  id           String  @id // Format: "parentId.subtaskId" (e.g., "1.1", "1.2")
  title        String
  description  String
  details      String?
  testStrategy String?
  status       String  // same status values as Task
  
  // Parent relationship
  parentId     Int
  parentTask   Task    @relation(fields: [parentId], references: [id], onDelete: Cascade)
  
  // Subtask dependencies (array stored as JSON)
  dependencies String  @default("[]") // JSON array of subtask IDs
  
  // Relationships with issues
  issues       Issue[]
  
  // Timestamps
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@map("subtasks")
}

// Task dependency junction table
model TaskDependency {
  id           Int  @id @default(autoincrement())
  
  // The task that depends on another
  taskId       Int
  task         Task @relation("TaskToDependencies", fields: [taskId], references: [id], onDelete: Cascade)
  
  // The task that is depended upon
  dependsOnId  Int
  dependsOn    Task @relation("DependencyToTasks", fields: [dependsOnId], references: [id], onDelete: Cascade)
  
  // Timestamps
  createdAt    DateTime @default(now())
  
  @@unique([taskId, dependsOnId])
  @@map("task_dependencies")
}

// Task Master metadata model
model TaskMasterMetadata {
  id          Int      @id @default(autoincrement())
  created     DateTime
  updated     DateTime
  description String
  
  // Only one metadata record should exist
  @@map("taskmaster_metadata")
}

// Sync operation tracking for the sync system
model SyncOperation {
  id           String   @id @default(cuid())
  type         String   // 'task_update', 'task_create', 'task_delete', 'status_change', 'batch_update', 'file_sync'
  status       String   // 'pending', 'executing', 'completed', 'failed', 'cancelled'
  source       String   // 'ui', 'cli', 'file'
  timestamp    DateTime @default(now())
  completedAt  DateTime?
  
  // Operation data stored as JSON
  data         String   // JSON string containing operation data
  rollbackData String?  // JSON string for rollback data
  metadata     String?  // JSON string for additional metadata
  
  // Retry and error handling
  retryCount   Int      @default(0)
  maxRetries   Int      @default(3)
  error        String?  // Error message if failed
  
  // Task relationships (multiple tasks can be affected)
  taskIds      String   @default("[]") // JSON array of task IDs
  
  @@map("sync_operations")
}

// Sync conflict tracking
model SyncConflict {
  id           String    @id @default(cuid())
  operationType String   // sync operation type that caused conflict
  taskId       String    // task ID involved in conflict
  
  // Conflict data
  uiVersion    String    // JSON string of UI version
  cliVersion   String    // JSON string of CLI/file version
  
  // Resolution
  resolved     Boolean   @default(false)
  resolution   String?   // 'ui_wins', 'cli_wins', 'last_write_wins', 'merge', 'user_resolve'
  resolvedAt   DateTime?
  resolvedBy   String?
  
  // Timestamps
  timestamp    DateTime  @default(now())
  
  @@map("sync_conflicts")
}

// User model for issue assignment and management
model User {
  id          String    @id @default(cuid())
  name        String
  email       String    @unique
  avatarUrl   String?
  status      String @default("OFFLINE") // UserStatus: ONLINE, OFFLINE, AWAY
  role        String @default("MEMBER") // UserRole: ADMIN, MEMBER, GUEST
  joinedDate  DateTime
  teamIds     String     @default("[]") // JSON array of team IDs for backwards compatibility

  // Relationships
  assignedIssues Issue[] @relation("IssueAssignee")
  teams          TeamMember[] @relation("TeamMemberUser")
  ledProjects    Project[] @relation("ProjectLead")

  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@map("users")
}

// Project model for organizing issues
model Project {
  id             String        @id @default(cuid())
  name           String
  description    String?
  color          String?
  identifier     String?       // Short project identifier (e.g., "LNUI")
  icon           String?       // Icon identifier from Lucide or other icon sets
  percentComplete Int          @default(0) // Progress percentage (0-100)
  startDate      DateTime?
  health         String @default("ON_TRACK") // ProjectHealth: NO_UPDATE, OFF_TRACK, ON_TRACK, AT_RISK
  leadId         String?

  // Relationships
  issues         Issue[]
  lead           User?         @relation("ProjectLead", fields: [leadId], references: [id], onDelete: SetNull)
  teams          TeamProject[] @relation("TeamProjectProject")

  // Timestamps
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  @@map("projects")
}

// Label model for categorizing issues
model Label {
  id          String      @id @default(cuid())
  name        String
  color       String
  description String?

  // Relationships
  issues      IssueLabel[]

  // Timestamps
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  @@map("labels")
}

// IssueStatus model for issue status management
model IssueStatus {
  id          String @id // Matches mock-data id (e.g., 'in-progress', 'completed')
  name        String // Display name (e.g., 'In Progress', 'Completed')
  color       String // Hex color for UI (e.g., '#facc15')
  iconName    String // Icon identifier for UI components

  // Relationships
  issues      Issue[]

  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("issue_statuses")
}

// IssuePriority model for issue priority management  
model IssuePriority {
  id          String @id // Matches mock-data id (e.g., 'high', 'medium', 'low')
  name        String // Display name (e.g., 'High', 'Medium', 'Low')
  iconName    String // Icon identifier for UI components
  order       Int    // Order for sorting priorities (0 = highest priority)

  // Relationships
  issues      Issue[]

  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("issue_priorities")
}

// Issue model - wraps tasks with additional board metadata
model Issue {
  id          String      @id @default(cuid())
  identifier  String      @unique // e.g., "LNUI-101"
  title       String
  description String
  statusId    String?     // Reference to IssueStatus (nullable during migration)
  priorityId  String?     // Reference to IssuePriority (nullable during migration)
  status      String?     // Legacy field (will be removed after migration)
  priority    String?     // Legacy field (will be removed after migration)
  rank        String      // LexoRank for ordering
  cycleId     String?     // Sprint/cycle identifier
  dueDate     DateTime?

  // Task Master integration
  taskId      Int?        // Reference to Task
  subtaskId   String?     // Reference to Subtask
  issueType   String // IssueType: TASK, SUBTASK

  // Parent issue for sub-issues
  parentIssueId String?
  
  // Relationships
  assigneeId  String?
  assignee    User?         @relation("IssueAssignee", fields: [assigneeId], references: [id], onDelete: SetNull)
  projectId   String?
  project     Project?      @relation(fields: [projectId], references: [id], onDelete: SetNull)
  cycle       Cycle?        @relation(fields: [cycleId], references: [id], onDelete: SetNull)
  task        Task?         @relation(fields: [taskId], references: [id], onDelete: SetNull)
  subtask     Subtask?      @relation(fields: [subtaskId], references: [id], onDelete: SetNull)
  issueStatus    IssueStatus?   @relation(fields: [statusId], references: [id], onDelete: Restrict)
  issuePriority  IssuePriority? @relation(fields: [priorityId], references: [id], onDelete: Restrict)
  labels      IssueLabel[]
  parentIssue Issue?        @relation("IssueSubIssues", fields: [parentIssueId], references: [id], onDelete: SetNull)
  subIssues   Issue[]       @relation("IssueSubIssues")

  // Timestamps
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@map("issues")
}

// Junction table for Issue-Label many-to-many relationship
model IssueLabel {
  id      String @id @default(cuid())
  issueId String
  labelId String

  issue   Issue  @relation(fields: [issueId], references: [id], onDelete: Cascade)
  label   Label  @relation(fields: [labelId], references: [id], onDelete: Cascade)

  @@unique([issueId, labelId])
  @@map("issue_labels")
}

// Cycle model for sprint/iteration management
model Cycle {
  id        String   @id @default(cuid())
  number    Int
  name      String
  teamId    String
  startDate DateTime
  endDate   DateTime
  progress  Int      @default(0) // Progress percentage (0-100)

  // Relationships
  team      Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  issues    Issue[]

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("cycles")
}

// Team model for organization and membership
model Team {
  id      String  @id @default(cuid())
  name    String
  icon    String  // Emoji or icon identifier
  joined  Boolean @default(false)
  color   String

  // Relationships
  members  TeamMember[] @relation("TeamMemberTeam")
  projects TeamProject[] @relation("TeamProjectTeam")
  cycles   Cycle[]

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("teams")
}

// Junction table for Team-User many-to-many relationship
model TeamMember {
  id     String @id @default(cuid())
  teamId String
  userId String

  team Team @relation("TeamMemberTeam", fields: [teamId], references: [id], onDelete: Cascade)
  user User @relation("TeamMemberUser", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([teamId, userId])
  @@map("team_members")
}

// Junction table for Team-Project many-to-many relationship
model TeamProject {
  id        String @id @default(cuid())
  teamId    String
  projectId String

  team    Team    @relation("TeamProjectTeam", fields: [teamId], references: [id], onDelete: Cascade)
  project Project @relation("TeamProjectProject", fields: [projectId], references: [id], onDelete: Cascade)

  @@unique([teamId, projectId])
  @@map("team_projects")
}

// Note: SQLite doesn't support enums, so we use strings with comments above
// Enum values are documented in the field comments above
